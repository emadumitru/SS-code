

File: core/src/main/java/io/undertow/UndertowLogger.java
/*
 * JBoss, Home of Professional Open Source.
 * Copyright 2014 Red Hat, Inc., and individual contributors
 * as indicated by the @author tags.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package io.undertow;

import io.undertow.client.ClientConnection;
import io.undertow.server.ServerConnection;
import io.undertow.util.HeaderMap;
import io.undertow.util.HttpString;
import org.jboss.logging.BasicLogger;
import org.jboss.logging.Logger;
import org.jboss.logging.annotations.Cause;
import org.jboss.logging.annotations.LogMessage;
import org.jboss.logging.annotations.Message;
import org.jboss.logging.annotations.MessageLogger;

import java.io.IOException;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.SocketAddress;
import java.net.URI;
import java.nio.file.Path;
import java.sql.SQLException;
import java.util.List;

import static org.jboss.logging.Logger.Level.DEBUG;
import static org.jboss.logging.Logger.Level.INFO;
import static org.jboss.logging.Logger.Level.WARN;

/**
 * log messages start at 5000
 *
 * @author Stuart Douglas
 */
@MessageLogger(projectCode = "UT")
public interface UndertowLogger extends BasicLogger {

    UndertowLogger ROOT_LOGGER = Logger.getMessageLogger(UndertowLogger.class, UndertowLogger.class.getPackage().getName());
    UndertowLogger CLIENT_LOGGER = Logger.getMessageLogger(UndertowLogger.class, ClientConnection.class.getPackage().getName());

    UndertowLogger REQUEST_LOGGER = Logger.getMessageLogger(UndertowLogger.class, UndertowLogger.class.getPackage().getName() + ".request");
    UndertowLogger PROXY_REQUEST_LOGGER = Logger.getMessageLogger(UndertowLogger.class, UndertowLogger.class.getPackage().getName() + ".proxy");
    UndertowLogger REQUEST_DUMPER_LOGGER = Logger.getMessageLogger(UndertowLogger.class, UndertowLogger.class.getPackage().getName() + ".request.dump");
    /**
     * Logger used for IO exceptions. Generally these should be suppressed, because they are of little interest, and it is easy for an
     * attacker to fill up the logs by intentionally causing IO exceptions.
     */
    UndertowLogger REQUEST_IO_LOGGER = Logger.getMessageLogger(UndertowLogger.class, UndertowLogger.class.getPackage().getName() + ".request.io");

    @LogMessage(level = Logger.Level.ERROR)
    @Message(id = 5001, value = "An exception occurred processing the request")
    void exceptionProcessingRequest(@Cause Throwable cause);

    @LogMessage(level = INFO)
    @Message(id = 5002, value = "Exception reading file %s: %s")
    void exceptionReadingFile(final Path file, final IOException e);

    @LogMessage(level = Logger.Level.ERROR)
    @Message(id = 5003, value = "IOException reading from channel")
    void ioExceptionReadingFromChannel(@Cause IOException e);

    @LogMessage(level = Logger.Level.ERROR)
    @Message(id = 5005, value = "Cannot remove uploaded file %s")
    void cannotRemoveUploadedFile(Path file);

    @LogMessage(level = Logger.Level.ERROR)
    @Message(id = 5006, value = "Connection from %s terminated as request header was larger than %s")
    void requestHeaderWasTooLarge(SocketAddress address, int size);

    @LogMessage(level = DEBUG)
    @Message(id = 5007, value = "Request was not fully consumed")
    void requestWasNotFullyConsumed();

    @LogMessage(level = DEBUG)
    @Message(id = 5008, value = "An invalid token '%s' with value '%s' has been received.")
    void invalidTokenReceived(final String tokenName, final String tokenValue);

    @LogMessage(level = DEBUG)
    @Message(id = 5009, value = "A mandatory token %s is missing from the request.")
    void missingAuthorizationToken(final String tokenName);

    @LogMessage(level = DEBUG)
    @Message(id = 5010, value = "Verification of authentication tokens for user '%s' has failed using mechanism '%s'.")
    void authenticationFailed(final String userName, final String mechanism);

    @LogMessage(level = Logger.Level.ERROR)
    @Message(id = 5011, value = "Ignoring AJP request with prefix %s")
    void ignoringAjpRequestWithPrefixCode(byte prefix);

    @LogMessage(level = DEBUG)
    @Message(id = 5013, value = "An IOException occurred")
    void ioException(@Cause IOException e);

    @LogMessage(level = DEBUG)
    @Message(id = 5014, value = "Failed to parse HTTP request")
    void failedToParseRequest(@Cause Exception e);

    @LogMessage(level = Logger.Level.ERROR)
    @Message(id = 5015, value = "Error rotating access log")
    void errorRotatingAccessLog(@Cause IOException e);

    @LogMessage(level = Logger.Level.ERROR)
    @Message(id = 5016, value = "Error writing access log")
    void errorWritingAccessLog(@Cause IOException e);

    @LogMessage(level = Logger.Level.ERROR)
    @Message(id = 5017, value = "Unknown variable %s")
    void unknownVariable(String token);

    @LogMessage(level = Logger.Level.ERROR)
    @Message(id = 5018, value = "Exception invoking close listener %s")
    void exceptionInvokingCloseListener(ServerConnection.CloseListener l, @Cause Throwable e);

    @LogMessage(level = Logger.Level.ERROR)
    @Message(id = 5019, value = "Cannot upgrade connection")
    void cannotUpgradeConnection(@Cause Exception e);

    @LogMessage(level = Logger.Level.ERROR)
    @Message(id = 5020, value = "Error writing JDBC log")
    void errorWritingJDBCLog(@Cause SQLException e);

    @LogMessage(level = Logger.Level.ERROR)
    @Message(id = 5021, value = "Proxy request to %s timed out")
    void proxyRequestTimedOut(String requestURI);

    @LogMessage(level = Logger.Level.ERROR)
    @Message(id = 5022, value = "Exception generating error page %s")
    void exceptionGeneratingErrorPage(@Cause Exception e, String location);

    @LogMessage(level = Logger.Level.ERROR)
    @Message(id = 5023, value = "Exception handling request to %s")
    void exceptionHandlingRequest(@Cause Throwable t, String requestURI);

    @LogMessage(level = Logger.Level.ERROR)
    @Message(id = 5024, value = "Could not register resource change listener for caching resource manager, automatic invalidation of cached resource will not work")
    void couldNotRegisterChangeListener(@Cause Exception e);

    @LogMessage(level = Logger.Level.ERROR)
    @Message(id = 5025, value = "Could not initiate SPDY connection and no HTTP fallback defined")
    void couldNotInitiateSpdyConnection();

    @LogMessage(level = Logger.Level.ERROR)
    @Message(id = 5026, value = "Jetty ALPN support not found on boot class path, %s client will not be available.")
    void jettyALPNNotFound(String protocol);

    @LogMessage(level = Logger.Level.ERROR)
    @Message(id = 5027, value = "Timing out request to %s")
    void timingOutRequest(String requestURI);

    @LogMessage(level = Logger.Level.ERROR)
    @Message(id = 5028, value = "Proxy request to %s failed")
    void proxyRequestFailed(String requestURI, @Cause Exception e);

    @LogMessage(level = Logger.Level.ERROR)
    @Message(id = 5030, value = "Proxy request to %s could not resolve a backend server")
    void proxyRequestFailedToResolveBackend(String requestURI);

    @LogMessage(level = Logger.Level.ERROR)
    @Message(id = 5031, value = "Proxy request to %s could not connect to backend server %s")
    void proxyFailedToConnectToBackend(String requestURI, URI uri);

    @LogMessage(level = Logger.Level.ERROR)
    @Message(id = 5032, value = "Listener not making progress on framed channel, closing channel to prevent infinite loop")
    void listenerNotProgressing();

    @LogMessage(level = Logger.Level.ERROR)
    @Message(id = 5033, value = "Failed to initiate HTTP2 connection")
    void couldNotInitiateHttp2Connection();

    @LogMessage(level = Logger.Level.ERROR)
    @Message(id = 5034, value = "Remote endpoint failed to send initial settings frame in HTTP2 connection, frame type %s")
    void remoteEndpointFailedToSendInitialSettings(int type);

    @LogMessage(level = DEBUG)
    @Message(id = 5035, value = "Closing channel because of parse timeout for remote address %s")
    void parseRequestTimedOut(java.net.SocketAddress remoteAddress);

    @LogMessage(level = Logger.Level.ERROR)
    @Message(id = 5036, value = "ALPN negotiation failed for %s and no fallback defined, closing connection")
    void noALPNFallback(SocketAddress address);

    /**
     * Undertow mod_cluster proxy messages
     */
    @LogMessage(level = WARN)
    @Message(id = 5037, value = "Name of the cookie containing the session id, %s, had been too long and was truncated to: %s")
    void stickySessionCookieLengthTruncated(String original, String current);

    @LogMessage(level = DEBUG)
    @Message(id = 5038, value = "Balancer created: id: %s, name: %s, stickySession: %s, stickySessionCookie: %s, stickySessionPath: %s, stickySessionRemove: %s, stickySessionForce: %s, waitWorker: %s, maxattempts: %s")
    void balancerCreated(int id, String name, boolean stickySession, String stickySessionCookie, String stickySessionPath, boolean stickySessionRemove,
                                            boolean stickySessionForce, int waitWorker, int maxattempts);

    @LogMessage(level = INFO)
    @Message(id = 5039, value = "Undertow starts mod_cluster proxy advertisements on %s with frequency %s ms")
    void proxyAdvertisementsStarted(String address, int frequency);

    @LogMessage(level = DEBUG)
    @Message(id = 5040, value = "Gonna send payload:\n%s")
    void proxyAdvertiseMessagePayload(String payload);

    @LogMessage(level = Logger.Level.ERROR)
    @Message(id = 5041, value = "Cannot send advertise message. Address: %s")
    void proxyAdvertiseCannotSendMessage(@Cause Exception e, InetSocketAddress address);

    @LogMessage(level = DEBUG)
    @Message(id = 5042, value = "Undertow mod_cluster proxy MCMPHandler created")
    void mcmpHandlerCreated();

    @LogMessage(level = Logger.Level.ERROR)
    @Message(id = 5043, value = "Error in processing MCMP commands: Type:%s, Mess: %s")
    void mcmpProcessingError(String type, String errString);

    @LogMessage(level = INFO)
    @Message(id = 5044, value = "Removing node %s")
    void removingNode(String jvmRoute);

    // Aliases intentionally omitted from INFO level.
    @LogMessage(level = INFO)
    @Message(id = 5045, value = "Registering context %s, for node %s")
    void registeringContext(String contextPath, String jvmRoute);

    // Context path and JVMRoute redundantly logged with DEBUG soa s to provide meaning for aliases.
    @LogMessage(level = DEBUG)
    @Message(id = 5046, value = "Registering context %s, for node %s, with aliases %s")
    void registeringContext(String contextPath, String jvmRoute, List<String> aliases);

    @LogMessage(level = INFO)
    @Message(id = 5047, value = "Unregistering context %s, from node %s")
    void unregisteringContext(String contextPath, String jvmRoute);

    @LogMessage(level = DEBUG)
    @Message(id = 5048, value = "Node %s in error")
    void nodeIsInError(String jvmRoute);

    @LogMessage(level = DEBUG)
    @Message(id = 5049, value = "NodeConfig created: connectionURI: %s, balancer: %s, domain: %s, jvmRoute: %s, flushPackets: %s, flushwait: %s, ping: %s," +
            "ttl: %s, timeout: %s, maxConnections: %s, cacheConnections: %s, requestQueueSize: %s, queueNewRequests: %s")
    void nodeConfigCreated(URI connectionURI, String balancer, String domain, String jvmRoute, boolean flushPackets, int flushwait, int ping, long ttl,
                           int timeout, int maxConnections, int cacheConnections, int requestQueueSize, boolean queueNewRequests);

    @LogMessage(level = Logger.Level.ERROR)
    @Message(id = 5050, value = "Failed to process management request")
    void failedToProcessManagementReq(@Cause Exception e);

    @LogMessage(level = Logger.Level.ERROR)
    @Message(id = 5051, value = "Failed to send ping response")
    void failedToSendPingResponse(@Cause Exception e);

    @LogMessage(level = DEBUG)
    @Message(id = 5052, value = "Failed to send ping response, node.getJvmRoute(): %s, jvmRoute: %s")
    void failedToSendPingResponseDBG(@Cause Exception e, String node, String jvmRoute);

    @LogMessage(level = INFO)
    @Message(id = 5053, value = "Registering node %s, connection: %s")
    void registeringNode(String jvmRoute, URI connectionURI);

    @LogMessage(level = DEBUG)
    @Message(id = 5054, value = "MCMP processing, key: %s, value: %s")
    void mcmpKeyValue(HttpString name, String value);

    @LogMessage(level = DEBUG)
    @Message(id = 5055, value = "HttpClientPingTask run for connection: %s")
    void httpClientPingTask(URI connection);

    @LogMessage(level = DEBUG)
    @Message(id = 5056, value = "Received node load in STATUS message, node jvmRoute: %s, load: %s")
    void receivedNodeLoad(String jvmRoute, String loadValue);

    @LogMessage(level = DEBUG)
    @Message(id = 5057, value = "Sending MCMP response to destination: %s, HTTP status: %s, Headers: %s, response: %s")
    void mcmpSendingResponse(InetSocketAddress destination, int status, HeaderMap headers, String response);

    @LogMessage(level = WARN)
    @Message(id = 5058, value = "Could not bind multicast socket to %s (%s address): %s; make sure your multicast address is of the same type as the IP stack (IPv4 or IPv6). Multicast socket will not be bound to an address, but this may lead to cross talking (see http://www.jboss.org/community/docs/DOC-9469 for details).")
    void potentialCrossTalking(InetAddress group, String s, String localizedMessage);

    @LogMessage(level = WARN)
    @Message(id = 5059, value = "Request dumping handler is in use. This handler is intended for debugging use only, and may dump sensitive data to the logs")
    void warnRequestDumpingHandler();

    @LogMessage(level = org.jboss.logging.Logger.Level.WARN)
    @Message(id = 5060, value = "Predicate %s uses old style square braces to define predicates, which will be removed in a future release. predicate[value] should be changed to predicate(value)")
    void oldStylePredicateSyntax(String string);

    @Message(id=5061, value = "More than %s restarts detected, breaking assumed infinite loop")
    IllegalStateException maxRestartsExceeded(int maxRestarts);
}


File: core/src/main/java/io/undertow/predicate/ContainsPredicate.java
/*
 * JBoss, Home of Professional Open Source.
 * Copyright 2014 Red Hat, Inc., and individual contributors
 * as indicated by the @author tags.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package io.undertow.predicate;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import io.undertow.attribute.ExchangeAttribute;
import io.undertow.server.HttpServerExchange;

/**
 * Returns true if the request header is present and contains one of the strings to match.
 *
 * @author Stuart Douglas
 */
public class ContainsPredicate implements Predicate {

    private final ExchangeAttribute attribute;
    private final String[] values;

    ContainsPredicate(final ExchangeAttribute attribute, final String[] values) {
        this.attribute = attribute;
        this.values = new String[values.length];
        System.arraycopy(values, 0, this.values, 0, values.length);
    }

    @Override
    public boolean resolve(final HttpServerExchange value) {
        String attr = attribute.readAttribute(value);
        if (attr == null) {
            return false;
        }
        for (int i = 0; i < values.length; ++i) {
            if (attr.contains(values[i])) {
                return true;
            }
        }
        return false;
    }

    public ExchangeAttribute getAttribute() {
        return attribute;
    }

    public String[] getValues() {
        String[] ret = new String[values.length];
        System.arraycopy(values, 0, ret, 0, values.length);
        return ret;
    }

    public static class Builder implements PredicateBuilder {

        @Override
        public String name() {
            return "contains";
        }

        @Override
        public Map<String, Class<?>> parameters() {
            final Map<String, Class<?>> params = new HashMap<>();
            params.put("value", ExchangeAttribute.class);
            params.put("search", String[].class);
            return params;
        }

        @Override
        public Set<String> requiredParameters() {
            final Set<String> params = new HashSet<>();
            params.add("value");
            params.add("search");
            return params;
        }

        @Override
        public String defaultParameter() {
            return null;
        }

        @Override
        public Predicate build(final Map<String, Object> config) {
            String[] search = (String[]) config.get("search");
            ExchangeAttribute values = (ExchangeAttribute) config.get("value");
            return new ContainsPredicate(values, search);
        }
    }
}


File: core/src/main/java/io/undertow/predicate/PredicateParser.java
/*
 * JBoss, Home of Professional Open Source.
 * Copyright 2014 Red Hat, Inc., and individual contributors
 * as indicated by the @author tags.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package io.undertow.predicate;

import io.undertow.server.handlers.builder.PredicatedHandlersParser;

/**
 * Parser that can build a predicate from a string representation. The underlying syntax is quite simple, and example is
 * shown below:
 * <p>
 * <code>
 * path["/MyPath"] or (method[value="POST"] and not headersPresent[value={Content-Type, "Content-Encoding"}, ignoreTrailer=true]
 * </code>
 * <p>
 * The following boolean operators are built in, listed in order or precedence:
 * - not
 * - and
 * - or
 * <p>
 * They work pretty much as you would expect them to. All other tokens are taken
 * to be predicate names. If the predicate does not require any parameters then the
 * brackets can be omitted, otherwise they are mandatory.
 * <p>
 * If a predicate is only being passed a single parameter then the parameter name can be omitted.
 * Strings can be enclosed in optional double or single quotations marks, and quotation marks can be escaped using
 * <code>\"</code>.
 * <p>
 * Array types are represented via a comma separated list of values enclosed in curly braces.
 * <p>
 * TODO: should we use antlr (or whatever) here? I don't really want an extra dependency just for this...
 *
 * @author Stuart Douglas
 */
public class PredicateParser {

    public static final Predicate parse(String string, final ClassLoader classLoader) {
        return PredicatedHandlersParser.parsePredicate(string, classLoader);
    }

}


File: core/src/main/java/io/undertow/predicate/PredicatesHandler.java
/*
 * JBoss, Home of Professional Open Source.
 * Copyright 2014 Red Hat, Inc., and individual contributors
 * as indicated by the @author tags.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package io.undertow.predicate;

import io.undertow.UndertowLogger;
import io.undertow.server.HandlerWrapper;
import io.undertow.server.HttpHandler;
import io.undertow.server.HttpServerExchange;
import io.undertow.server.handlers.builder.HandlerBuilder;
import io.undertow.server.handlers.builder.PredicatedHandler;
import io.undertow.util.AttachmentKey;

import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;

/**
 * Handler that can deal with a large number of predicates. chaining together a large number of {@link io.undertow.predicate.PredicatesHandler.Holder}
 * instances will make the stack grow to large, so this class is used that can deal with a large number of predicates.
 *
 * @author Stuart Douglas
 */
public class PredicatesHandler implements HttpHandler {

    /**
     * static done marker. If this is attached to the exchange it will drop out immediately.
     */
    public static final AttachmentKey<Boolean> DONE = AttachmentKey.create(Boolean.class);
    public static final AttachmentKey<Boolean> RESTART = AttachmentKey.create(Boolean.class);

    private volatile Holder[] handlers = new Holder[0];
    private volatile HttpHandler next;
    private final boolean outerHandler;

    //non-static, so multiple handlers can co-exist
    private final AttachmentKey<Integer> CURRENT_POSITION = AttachmentKey.create(Integer.class);

    public PredicatesHandler(HttpHandler next) {
        this.next = next;
        this.outerHandler = true;
    }
    public PredicatesHandler(HttpHandler next, boolean outerHandler) {
        this.next = next;
        this.outerHandler = outerHandler;
    }

    @Override
    public void handleRequest(HttpServerExchange exchange) throws Exception {
        final int length = handlers.length;
        Integer current = exchange.getAttachment(CURRENT_POSITION);
        do {
            int pos;
            if (current == null) {
                if (outerHandler) {
                    exchange.removeAttachment(RESTART);
                    exchange.removeAttachment(DONE);
                    if (exchange.getAttachment(Predicate.PREDICATE_CONTEXT) == null) {
                        exchange.putAttachment(Predicate.PREDICATE_CONTEXT, new TreeMap<String, Object>());
                    }
                }
                pos = 0;
            } else {
                //if it has been marked as done
                if (exchange.getAttachment(DONE) != null) {
                    exchange.removeAttachment(CURRENT_POSITION);
                    next.handleRequest(exchange);
                    return;
                }
                pos = current;
            }
            for (; pos < length; ++pos) {
                final Holder handler = handlers[pos];
                if (handler.predicate.resolve(exchange)) {
                    exchange.putAttachment(CURRENT_POSITION, pos + 1);
                    handler.handler.handleRequest(exchange);
                    if(shouldRestart(exchange, current)) {
                        break;
                    } else {
                        return;
                    }
                } else if(handler.elseBranch != null) {
                    exchange.putAttachment(CURRENT_POSITION, pos + 1);
                    handler.elseBranch.handleRequest(exchange);
                    if(shouldRestart(exchange, current)) {
                        break;
                    } else {
                        return;
                    }
                }
            }
        } while (shouldRestart(exchange, current));
        next.handleRequest(exchange);

    }

    private boolean shouldRestart(HttpServerExchange exchange, Integer current) {
        return exchange.getAttachment(RESTART) != null && outerHandler && current == null;
    }

    /**
     * Adds a new predicated handler.
     * <p>
     *
     * @param predicate
     * @param handlerWrapper
     */
    public PredicatesHandler addPredicatedHandler(final Predicate predicate, final HandlerWrapper handlerWrapper, final HandlerWrapper elseBranch) {
        Holder[] old = handlers;
        Holder[] handlers = new Holder[old.length + 1];
        System.arraycopy(old, 0, handlers, 0, old.length);
        HttpHandler elseHandler = elseBranch != null ? elseBranch.wrap(this) : null;
        handlers[old.length] = new Holder(predicate, handlerWrapper.wrap(this), elseHandler);
        this.handlers = handlers;
        return this;
    }

    /**
     * Adds a new predicated handler.
     * <p>
     *
     * @param predicate
     * @param handlerWrapper
     */
    public PredicatesHandler addPredicatedHandler(final Predicate predicate, final HandlerWrapper handlerWrapper) {
        this.addPredicatedHandler(predicate, handlerWrapper, null);
        return this;
    }

    public PredicatesHandler addPredicatedHandler(final PredicatedHandler handler) {
        return addPredicatedHandler(handler.getPredicate(), handler.getHandler(), handler.getElseHandler());
    }

    public void setNext(HttpHandler next) {
        this.next = next;
    }

    public HttpHandler getNext() {
        return next;
    }

    private static final class Holder {
        final Predicate predicate;
        final HttpHandler handler;
        final HttpHandler elseBranch;

        private Holder(Predicate predicate, HttpHandler handler, HttpHandler elseBranch) {
            this.predicate = predicate;
            this.handler = handler;
            this.elseBranch = elseBranch;
        }
    }

    public static final class DoneHandlerBuilder implements HandlerBuilder {

        @Override
        public String name() {
            return "done";
        }

        @Override
        public Map<String, Class<?>> parameters() {
            return Collections.emptyMap();
        }

        @Override
        public Set<String> requiredParameters() {
            return Collections.emptySet();
        }

        @Override
        public String defaultParameter() {
            return null;
        }

        @Override
        public HandlerWrapper build(Map<String, Object> config) {
            return new HandlerWrapper() {
                @Override
                public HttpHandler wrap(final HttpHandler handler) {
                    return new HttpHandler() {
                        @Override
                        public void handleRequest(HttpServerExchange exchange) throws Exception {
                            exchange.putAttachment(DONE, true);
                            handler.handleRequest(exchange);
                        }
                    };
                }
            };
        }
    }

    public static final class RestartHandlerBuilder implements HandlerBuilder {

        private static final AttachmentKey<Integer> RESTART_COUNT = AttachmentKey.create(Integer.class);

        private static final int MAX_RESTARTS = Integer.getInteger("io.undertow.max_restarts", 1000);

        @Override
        public String name() {
            return "restart";
        }

        @Override
        public Map<String, Class<?>> parameters() {
            return Collections.emptyMap();
        }

        @Override
        public Set<String> requiredParameters() {
            return Collections.emptySet();
        }

        @Override
        public String defaultParameter() {
            return null;
        }

        @Override
        public HandlerWrapper build(Map<String, Object> config) {
            return new HandlerWrapper() {
                @Override
                public HttpHandler wrap(final HttpHandler handler) {
                    return new HttpHandler() {
                        @Override
                        public void handleRequest(HttpServerExchange exchange) throws Exception {
                            Integer restarts = exchange.getAttachment(RESTART_COUNT);
                            if(restarts == null) {
                                restarts = 1;
                            } else {
                                restarts++;
                            }
                            exchange.putAttachment(RESTART_COUNT, restarts);
                            if(restarts > MAX_RESTARTS) {
                                throw UndertowLogger.ROOT_LOGGER.maxRestartsExceeded(MAX_RESTARTS);
                            }
                            exchange.putAttachment(RESTART, true);
                        }
                    };
                }
            };
        }
    }


    public static class Wrapper implements HandlerWrapper {

        private final List<PredicatedHandler> handlers;
        private final boolean outerHandler;

        public Wrapper(List<PredicatedHandler> handlers, boolean outerHandler) {
            this.handlers = handlers;
            this.outerHandler = outerHandler;
        }

        @Override
        public HttpHandler wrap(HttpHandler handler) {
            PredicatesHandler h = new PredicatesHandler(handler, outerHandler);
            for(PredicatedHandler pred : handlers) {
                h.addPredicatedHandler(pred.getPredicate(), pred.getHandler());
            }
            return h;
        }
    }
}


File: core/src/main/java/io/undertow/server/handlers/AllowedMethodsHandler.java
/*
 * JBoss, Home of Professional Open Source.
 * Copyright 2014 Red Hat, Inc., and individual contributors
 * as indicated by the @author tags.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package io.undertow.server.handlers;

import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import io.undertow.server.HandlerWrapper;
import io.undertow.server.HttpHandler;
import io.undertow.server.HttpServerExchange;
import io.undertow.server.handlers.builder.HandlerBuilder;
import io.undertow.util.HttpString;
import io.undertow.util.StatusCodes;

/**
 * Handler that whitelists certain HTTP methods. Only requests with a method in
 * the allowed methods set will be allowed to continue.
 *
 * @author Stuart Douglas
 */
public class AllowedMethodsHandler implements HttpHandler {

    private final Set<HttpString> allowedMethods;
    private final HttpHandler next;

    public AllowedMethodsHandler(final HttpHandler next, final Set<HttpString> allowedMethods) {
        this.allowedMethods = new HashSet<>(allowedMethods);
        this.next = next;
    }

    public AllowedMethodsHandler(final HttpHandler next, final HttpString... allowedMethods) {
        this.allowedMethods = new HashSet<>(Arrays.asList(allowedMethods));
        this.next = next;
    }

    @Override
    public void handleRequest(final HttpServerExchange exchange) throws Exception {
        if (allowedMethods.contains(exchange.getRequestMethod())) {
            next.handleRequest(exchange);
        } else {
            exchange.setResponseCode(StatusCodes.METHOD_NOT_ALLOWED);
            exchange.endExchange();
        }
    }

    public Set<HttpString> getAllowedMethods() {
        return Collections.unmodifiableSet(allowedMethods);
    }

    public static class Builder implements HandlerBuilder {

        @Override
        public String name() {
            return "allowed-methods";
        }

        @Override
        public Map<String, Class<?>> parameters() {
            return Collections.<String, Class<?>>singletonMap("methods", String[].class);
        }

        @Override
        public Set<String> requiredParameters() {
            return Collections.singleton("methods");
        }

        @Override
        public String defaultParameter() {
            return "methods";
        }

        @Override
        public HandlerWrapper build(Map<String, Object> config) {
            return new Wrapper((String[]) config.get("methods"));
        }

    }

    private static class Wrapper implements HandlerWrapper {

        private final String[] methods;

        private Wrapper(String[] methods) {
            this.methods = methods;
        }

        @Override
        public HttpHandler wrap(HttpHandler handler) {
            HttpString[] strings = new HttpString[methods.length];
                for(int i = 0; i < methods.length; ++i) {
                    strings[i] = new HttpString(methods[i]);
                }

            return new AllowedMethodsHandler(handler, strings);
        }
    }
}


File: core/src/main/java/io/undertow/server/handlers/SetHeaderHandler.java
/*
 * JBoss, Home of Professional Open Source.
 * Copyright 2014 Red Hat, Inc., and individual contributors
 * as indicated by the @author tags.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package io.undertow.server.handlers;

import io.undertow.UndertowMessages;
import io.undertow.attribute.ExchangeAttribute;
import io.undertow.attribute.ExchangeAttributes;
import io.undertow.server.HandlerWrapper;
import io.undertow.server.HttpHandler;
import io.undertow.server.HttpServerExchange;
import io.undertow.server.handlers.builder.HandlerBuilder;
import io.undertow.util.HttpString;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

/**
 * Set a fixed response header.
 *
 * @author Stuart Douglas
 */
public class SetHeaderHandler implements HttpHandler {

    private final HttpString header;
    private final ExchangeAttribute value;
    private final HttpHandler next;

    public SetHeaderHandler(final String header, final String value) {
        if(value == null) {
            throw UndertowMessages.MESSAGES.argumentCannotBeNull("value");
        }
        if(header == null) {
            throw UndertowMessages.MESSAGES.argumentCannotBeNull("header");
        }
        this.next = ResponseCodeHandler.HANDLE_404;
        this.value = ExchangeAttributes.constant(value);
        this.header = new HttpString(header);
    }

    public SetHeaderHandler(final HttpHandler next, final String header, final ExchangeAttribute value) {
        if(value == null) {
            throw UndertowMessages.MESSAGES.argumentCannotBeNull("value");
        }
        if(header == null) {
            throw UndertowMessages.MESSAGES.argumentCannotBeNull("header");
        }
        if(next == null) {
            throw UndertowMessages.MESSAGES.argumentCannotBeNull("next");
        }
        this.next = next;
        this.value = value;
        this.header = new HttpString(header);
    }

    public SetHeaderHandler(final HttpHandler next, final String header, final String value) {
        if(value == null) {
            throw UndertowMessages.MESSAGES.argumentCannotBeNull("value");
        }
        if(header == null) {
            throw UndertowMessages.MESSAGES.argumentCannotBeNull("header");
        }
        if(next == null) {
            throw UndertowMessages.MESSAGES.argumentCannotBeNull("next");
        }
        this.next = next;
        this.value = ExchangeAttributes.constant(value);
        this.header = new HttpString(header);
    }
    @Override
    public void handleRequest(final HttpServerExchange exchange) throws Exception {
        exchange.getResponseHeaders().put(header, value.readAttribute(exchange));
        next.handleRequest(exchange);
    }

    public ExchangeAttribute getValue() {
        return value;
    }

    public HttpString getHeader() {
        return header;
    }

    public static class Builder implements HandlerBuilder {
        @Override
        public String name() {
            return "header";
        }

        @Override
        public Map<String, Class<?>> parameters() {
            Map<String, Class<?>> parameters = new HashMap<>();
            parameters.put("header", String.class);
            parameters.put("value", ExchangeAttribute.class);

            return parameters;
        }

        @Override
        public Set<String> requiredParameters() {
            final Set<String> req = new HashSet<>();
            req.add("value");
            req.add("header");
            return req;
        }

        @Override
        public String defaultParameter() {
            return null;
        }

        @Override
        public HandlerWrapper build(final Map<String, Object> config) {
            final ExchangeAttribute value = (ExchangeAttribute) config.get("value");
            final String header = (String) config.get("header");

            return new HandlerWrapper() {
                @Override
                public HttpHandler wrap(HttpHandler handler) {
                    return new SetHeaderHandler(handler, header, value);
                }
            };
        }
    }
}


File: core/src/main/java/io/undertow/server/handlers/builder/HandlerParser.java
/*
 * JBoss, Home of Professional Open Source.
 * Copyright 2014 Red Hat, Inc., and individual contributors
 * as indicated by the @author tags.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package io.undertow.server.handlers.builder;

import io.undertow.server.HandlerWrapper;

/**
 * Parser that can build a handler from a string representation. The underlying syntax is quite simple, and example is
 * shown below:
 * <p>
 * <code>
 * rewrite[value="/path"]
 * </code>
 * If a handler is only being passed a single parameter then the parameter name can be omitted.
 * Strings can be enclosed in optional double or single quotations marks, and quotation marks can be escaped using
 * <code>\"</code>.
 * <p>
 * Array types are represented via a comma separated list of values enclosed in curly braces.
 * <p>
 *
 * @author Stuart Douglas
 */
public class HandlerParser {


    public static HandlerWrapper parse(String string, final ClassLoader classLoader) {
        return PredicatedHandlersParser.parseHandler(string, classLoader);
    }


}


File: core/src/main/java/io/undertow/server/handlers/builder/PredicatedHandler.java
/*
 * JBoss, Home of Professional Open Source.
 * Copyright 2014 Red Hat, Inc., and individual contributors
 * as indicated by the @author tags.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package io.undertow.server.handlers.builder;

import io.undertow.predicate.Predicate;
import io.undertow.server.HandlerWrapper;

/**
 * @author Stuart Douglas
 */
public class PredicatedHandler {
    private final Predicate predicate;
    private final HandlerWrapper handler;
    private final HandlerWrapper elseHandler;

    public PredicatedHandler(Predicate predicate, HandlerWrapper handler) {
        this(predicate, handler, null);
    }

    public PredicatedHandler(Predicate predicate, HandlerWrapper handler, HandlerWrapper elseHandler) {
        this.predicate = predicate;
        this.handler = handler;
        this.elseHandler = elseHandler;
    }

    public Predicate getPredicate() {
        return predicate;
    }

    public HandlerWrapper getHandler() {
        return handler;
    }

    public HandlerWrapper getElseHandler() {
        return elseHandler;
    }
}


File: core/src/main/java/io/undertow/server/handlers/builder/PredicatedHandlersParser.java
/*
 * JBoss, Home of Professional Open Source.
 * Copyright 2014 Red Hat, Inc., and individual contributors
 * as indicated by the @author tags.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package io.undertow.server.handlers.builder;

import io.undertow.UndertowLogger;
import io.undertow.UndertowMessages;
import io.undertow.attribute.ExchangeAttribute;
import io.undertow.attribute.ExchangeAttributeParser;
import io.undertow.attribute.ExchangeAttributes;
import io.undertow.predicate.Predicate;
import io.undertow.predicate.PredicateBuilder;
import io.undertow.predicate.Predicates;
import io.undertow.predicate.PredicatesHandler;
import io.undertow.server.HandlerWrapper;
import io.undertow.util.FileUtils;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.Array;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Deque;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.ServiceLoader;

/**
 * Parser for the undertow-handlers.conf file.
 * <p/>
 * This file has a line by line syntax, specifying predicate -&gt; handler. If no predicate is specified then
 * the line is assumed to just contain a handler.
 *
 * @author Stuart Douglas
 */
public class PredicatedHandlersParser {

    public static final String ELSE = "else";
    public static final String ARROW = "->";
    public static final String NOT = "not";
    public static final String OR = "or";
    public static final String AND = "and";
    public static final String TRUE = "true";
    public static final String FALSE = "false";

    public static List<PredicatedHandler> parse(final File file, final ClassLoader classLoader) {
        return parse(file.toPath(), classLoader);
    }

    public static List<PredicatedHandler> parse(final Path file, final ClassLoader classLoader) {
        try {
            return parse(new String(Files.readAllBytes(file)), classLoader);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public static List<PredicatedHandler> parse(final InputStream inputStream, final ClassLoader classLoader) {
        return parse(FileUtils.readFile(inputStream), classLoader);
    }

    public static List<PredicatedHandler> parse(final String contents, final ClassLoader classLoader) {
        Deque<Token> tokens = tokenize(contents);

        Node node = parse(contents, tokens);
        Map<String, PredicateBuilder> predicateBuilders = loadPredicateBuilders(classLoader);
        Map<String, HandlerBuilder> handlerBuilders = loadHandlerBuilders(classLoader);

        final ExchangeAttributeParser attributeParser = ExchangeAttributes.parser(classLoader);
        return handleNode(contents, node, predicateBuilders, handlerBuilders, attributeParser);
    }


    public static Predicate parsePredicate(String string, ClassLoader classLoader) {
        Deque<Token> tokens = tokenize(string);
        Node node = parse(string, tokens);
        Map<String, PredicateBuilder> predicateBuilders = loadPredicateBuilders(classLoader);
        final ExchangeAttributeParser attributeParser = ExchangeAttributes.parser(classLoader);
        return handlePredicateNode(string, node, predicateBuilders, attributeParser);
    }

    public static HandlerWrapper parseHandler(String string, ClassLoader classLoader) {
        Deque<Token> tokens = tokenize(string);
        Node node = parse(string, tokens);
        Map<String, HandlerBuilder> handlerBuilders = loadHandlerBuilders(classLoader);
        final ExchangeAttributeParser attributeParser = ExchangeAttributes.parser(classLoader);
        return handleHandlerNode(string, (ExpressionNode)node, handlerBuilders, attributeParser);
    }
    private static List<PredicatedHandler> handleNode(String contents, Node node, Map<String, PredicateBuilder> predicateBuilders, Map<String, HandlerBuilder> handlerBuilders, ExchangeAttributeParser attributeParser) {
        if(node instanceof BlockNode) {
            return handleBlockNode(contents, (BlockNode) node, predicateBuilders, handlerBuilders, attributeParser);
        } else if(node instanceof ExpressionNode) {
            HandlerWrapper handler =  handleHandlerNode(contents, (ExpressionNode) node, handlerBuilders, attributeParser);
            return Collections.singletonList(new PredicatedHandler(Predicates.truePredicate(), handler));
        } else if(node instanceof PredicateOperatorNode) {
            return Collections.singletonList(handlePredicateOperatorNode(contents, (PredicateOperatorNode)node, predicateBuilders, handlerBuilders, attributeParser));
        } else {
            throw error(contents, node.getToken().getPosition(), "unexpected token " + node.getToken());
        }
    }

    private static PredicatedHandler handlePredicateOperatorNode(String contents, PredicateOperatorNode node, Map<String, PredicateBuilder> predicateBuilders, Map<String, HandlerBuilder> handlerBuilders, ExchangeAttributeParser parser) {
        Predicate predicate = handlePredicateNode(contents, node.getLeft(), predicateBuilders, parser);
        HandlerWrapper ret = handlePredicatedAction(contents, node.getRight(), predicateBuilders, handlerBuilders, parser);
        HandlerWrapper elseBranch = null;
        if(node.getElseBranch() != null) {
            elseBranch = handlePredicatedAction(contents, node.getElseBranch(), predicateBuilders, handlerBuilders, parser);
        }
        return new PredicatedHandler(predicate, ret, elseBranch);
    }

    private static HandlerWrapper handlePredicatedAction(String contents, Node node, Map<String, PredicateBuilder> predicateBuilders, Map<String, HandlerBuilder> handlerBuilders, ExchangeAttributeParser parser) {
        if(node instanceof ExpressionNode) {
            return handleHandlerNode(contents, (ExpressionNode) node, handlerBuilders, parser);
        } else if(node instanceof BlockNode) {
            List<PredicatedHandler> handlers = handleBlockNode(contents, (BlockNode) node, predicateBuilders, handlerBuilders, parser);
            return  new PredicatesHandler.Wrapper(handlers, false);
        } else {
            throw error(contents, node.getToken().getPosition(), "unexpected token " + node.getToken());
        }
    }

    private static List<PredicatedHandler> handleBlockNode(String contents, BlockNode node, Map<String, PredicateBuilder> predicateBuilders, Map<String, HandlerBuilder> handlerBuilders, ExchangeAttributeParser parser) {
        List<PredicatedHandler> ret = new ArrayList<>();
        for(Node line : node.getBlock()) {
            ret.addAll(handleNode(contents, line, predicateBuilders, handlerBuilders, parser));
        }
        return ret;

    }

    private static HandlerWrapper handleHandlerNode(String contents, ExpressionNode node, Map<String, HandlerBuilder> handlerBuilders, ExchangeAttributeParser parser) {
        Token token = node.getToken();
        HandlerBuilder builder = handlerBuilders.get(token.getToken());
        if (builder == null) {
            throw error(contents, token.getPosition(), "no handler named " + token.getToken() + " known handlers are " + handlerBuilders.keySet());
        }
        Map<String, Object> parameters = new HashMap<>();

        for(Map.Entry<String, Node> val : node.getValues().entrySet()) {
            String name = val.getKey();
            if(name == null) {
                if(builder.defaultParameter() == null) {
                    throw error(contents, token.getPosition(), "default parameter not supported");
                }
                name = builder.defaultParameter();
            }
            Class<?> type = builder.parameters().get(name);
            if(type == null) {
                throw error(contents, val.getValue().getToken().getPosition(), "unknown parameter " + name);
            }
            if(val.getValue() instanceof ValueNode) {
                parameters.put(name, coerceToType(contents, val.getValue().getToken(), type, parser));
            } else if(val.getValue() instanceof ArrayNode) {
                parameters.put(name, readArrayType(contents, name, (ArrayNode)val.getValue(), parser, type));
            } else {
                throw error(contents, val.getValue().getToken().getPosition(), "unexpected node " + val.getValue());
            }
        }
        return builder.build(parameters);
    }

    private static Predicate handlePredicateNode(String contents, Node node, Map<String, PredicateBuilder> handlerBuilders, ExchangeAttributeParser parser) {
        if(node instanceof AndNode) {
            AndNode andNode = (AndNode)node;
            return Predicates.and(handlePredicateNode(contents, andNode.getLeft(), handlerBuilders, parser), handlePredicateNode(contents, andNode.getRight(), handlerBuilders, parser));
        } else if(node instanceof OrNode) {
            OrNode orNode = (OrNode)node;
            return Predicates.or(handlePredicateNode(contents, orNode.getLeft(), handlerBuilders, parser), handlePredicateNode(contents, orNode.getRight(), handlerBuilders, parser));
        } else if(node instanceof NotNode) {
            NotNode orNode = (NotNode)node;
            return Predicates.not(handlePredicateNode(contents, orNode.getNode(), handlerBuilders, parser));
        } else if(node instanceof ExpressionNode) {
            return handlePredicateExpressionNode(contents, (ExpressionNode) node, handlerBuilders, parser);
        }else if(node instanceof OperatorNode) {
            switch (node.getToken().getToken()) {
                case TRUE: {
                    return Predicates.truePredicate();
                }
                case FALSE: {
                    return Predicates.falsePredicate();
                }
            }
        }
        throw error(contents, node.getToken().getPosition(), "unexpected node " + node);
    }

    private static Predicate handlePredicateExpressionNode(String contents, ExpressionNode node, Map<String, PredicateBuilder> handlerBuilders, ExchangeAttributeParser parser) {
        Token token = node.getToken();
        PredicateBuilder builder = handlerBuilders.get(token.getToken());
        if (builder == null) {
            throw error(contents, token.getPosition(), "no predicate named " + token.getToken() + " known predicates are " + handlerBuilders.keySet());
        }
        Map<String, Object> parameters = new HashMap<>();

        for(Map.Entry<String, Node> val : node.getValues().entrySet()) {
            String name = val.getKey();
            if(name == null) {
                if(builder.defaultParameter() == null) {
                    throw error(contents, token.getPosition(), "default parameter not supported");
                }
                name = builder.defaultParameter();
            }
            Class<?> type = builder.parameters().get(name);
            if(type == null) {
                throw error(contents, val.getValue().getToken().getPosition(), "unknown parameter " + name);
            }
            if(val.getValue() instanceof ValueNode) {
                parameters.put(name, coerceToType(contents, val.getValue().getToken(), type, parser));
            } else if(val.getValue() instanceof ArrayNode) {
                parameters.put(name, readArrayType(contents, name, (ArrayNode)val.getValue(), parser, type));
            } else {
                throw error(contents, val.getValue().getToken().getPosition(), "unexpected node " + val.getValue());
            }
        }
        return builder.build(parameters);
    }

    private static Object readArrayType(final String string, String paramName, ArrayNode value, ExchangeAttributeParser parser, Class type) {
        if (!type.isArray()) {
            throw error(string, value.getToken().getPosition(), "parameter is not an array type " + paramName);
        }

        Class<?> componentType = type.getComponentType();
        final List<Object> values = new ArrayList<>();
        for(Token token : value.getValues()) {
            values.add(coerceToType(string, token, componentType, parser));
        }
        Object array = Array.newInstance(componentType, values.size());
        for (int i = 0; i < values.size(); ++i) {
            Array.set(array, i, values.get(i));
        }
        return array;
    }

    private static Object coerceToType(final String string, final Token token, final Class<?> type, final ExchangeAttributeParser attributeParser) {
        if (type.isArray()) {
            Object array = Array.newInstance(type.getComponentType(), 1);
            Array.set(array, 0, coerceToType(string, token, type.getComponentType(), attributeParser));
            return array;
        }

        if (type == String.class) {
            return token.getToken();
        } else if (type.equals(Boolean.class) || type.equals(boolean.class)) {
            return Boolean.valueOf(token.getToken());
        } else if (type.equals(Byte.class) || type.equals(byte.class)) {
            return Byte.valueOf(token.getToken());
        } else if (type.equals(Character.class) || type.equals(char.class)) {
            if (token.getToken().length() != 1) {
                throw error(string, token.getPosition(), "Cannot coerce " + token.getToken() + " to a Character");
            }
            return Character.valueOf(token.getToken().charAt(0));
        } else if (type.equals(Short.class) || type.equals(short.class)) {
            return Short.valueOf(token.getToken());
        } else if (type.equals(Integer.class) || type.equals(int.class)) {
            return Integer.valueOf(token.getToken());
        } else if (type.equals(Long.class) || type.equals(long.class)) {
            return Long.valueOf(token.getToken());
        } else if (type.equals(Float.class) || type.equals(float.class)) {
            return Float.valueOf(token.getToken());
        } else if (type.equals(Double.class) || type.equals(double.class)) {
            return Double.valueOf(token.getToken());
        } else if (type.equals(ExchangeAttribute.class)) {
            return attributeParser.parse(token.getToken());
        }

        return token.getToken();
    }

    private static Map<String, PredicateBuilder> loadPredicateBuilders(final ClassLoader classLoader) {
        ServiceLoader<PredicateBuilder> loader = ServiceLoader.load(PredicateBuilder.class, classLoader);
        final Map<String, PredicateBuilder> ret = new HashMap<>();
        for (PredicateBuilder builder : loader) {
            if (ret.containsKey(builder.name())) {
                if (ret.get(builder.name()).getClass() != builder.getClass()) {
                    throw UndertowMessages.MESSAGES.moreThanOnePredicateWithName(builder.name(), builder.getClass(), ret.get(builder.name()).getClass());
                }
            } else {
                ret.put(builder.name(), builder);
            }
        }
        return ret;
    }

    private static Map<String, HandlerBuilder> loadHandlerBuilders(final ClassLoader classLoader) {
        ServiceLoader<HandlerBuilder> loader = ServiceLoader.load(HandlerBuilder.class, classLoader);
        final Map<String, HandlerBuilder> ret = new HashMap<>();
        for (HandlerBuilder builder : loader) {
            if (ret.containsKey(builder.name())) {
                if (ret.get(builder.name()).getClass() != builder.getClass()) {
                    throw UndertowMessages.MESSAGES.moreThanOneHandlerWithName(builder.name(), builder.getClass(), ret.get(builder.name()).getClass());
                }
            } else {
                ret.put(builder.name(), builder);
            }
        }
        return ret;
    }

    static Node parse(final String string, Deque<Token> tokens) {
        return parse(string, tokens, true);
    }

    static Node parse(final String string, Deque<Token> tokens, boolean topLevel) {

        //shunting yard algorithm
        //gets rid or parentheses and fixes up operator ordering
        Deque<Token> operatorStack = new ArrayDeque<>();

        Deque<Node> output = new ArrayDeque<>();
        List<Node> blocks = new ArrayList<>();


        while (!tokens.isEmpty()) {
            Token token = tokens.poll();
            if(token.getToken().equals("{")) {
                output.push(parse(string, tokens, false));
            } else if(token.getToken().equals("}")) {
                if(topLevel) {
                    throw error(string, token.getPosition(), "Unexpected token");
                }
                break;
            } else if(token.getToken().equals("\n") || token.getToken().equals(";")) {
                handleLineEnd(string, operatorStack, output, blocks);
            } else if (isSpecialChar(token.getToken())) {
                if (token.getToken().equals("(")) {
                    operatorStack.push(token);
                } else if (token.getToken().equals(")")) {
                    for (; ; ) {
                        Token op = operatorStack.pop();
                        if (op == null) {
                            throw error(string, token.getPosition(), "Unexpected end of input");
                        } else if (op.getToken().equals("(")) {
                            break;
                        } else {
                            output.push(new OperatorNode(op));
                        }
                    }
                } else {
                    output.push(new OperatorNode(token));
                }
            } else {
                if (isOperator(token.getToken()) && !token.getToken().equals(ELSE)) {
                    int prec = precedence(token.getToken());
                    Token top = operatorStack.peek();
                    while (top != null) {
                        if (top.getToken().equals("(")) {
                            break;
                        }
                        int exitingPrec = precedence(top.getToken());
                        if (prec <= exitingPrec) {
                            output.push(new OperatorNode(operatorStack.pop()));
                        } else {
                            break;
                        }
                        top = operatorStack.peek();
                    }
                    operatorStack.push(token);
                } else {
                    output.push(parseExpression(string, token, tokens));
                }
            }
        }
        handleLineEnd(string, operatorStack, output, blocks);
        if(blocks.size() == 1) {
            return blocks.get(0);
        } else {
            return new BlockNode(new Token("", 0), blocks);
        }
    }

    private static void handleLineEnd(String string, Deque<Token> operatorStack, Deque<Node> output, List<Node> blocks) {
        while (!operatorStack.isEmpty()) {
            Token op = operatorStack.pop();
            if (op.getToken().equals(")")) {
                throw error(string, string.length(), "Mismatched parenthesis");
            }
            output.push(new OperatorNode(op));
        }
        if(output.isEmpty()) {
            return;
        }
        //now we have our tokens for this line
        Node predicate = collapseOutput(output.pop(), output);
        if (!output.isEmpty()) {
            throw error(string, output.getFirst().getToken().getPosition(), "Invalid expression");
        }
        blocks.add(predicate);
    }

    private static Node collapseOutput(final Node token, final Deque<Node> tokens) {
        if (token instanceof OperatorNode) {
            OperatorNode node = (OperatorNode) token;
            if (node.token.getToken().equals(AND)) {
                Node n1 = collapseOutput(tokens.pop(), tokens);
                Node n2 = collapseOutput(tokens.pop(), tokens);
                return new AndNode(token.getToken(), n2, n1);
            } else if (node.token.getToken().equals(OR)) {
                Node n1 = collapseOutput(tokens.pop(), tokens);
                Node n2 = collapseOutput(tokens.pop(), tokens);
                return new OrNode(token.getToken(), n2, n1);
            } else if (node.token.getToken().equals(NOT)) {
                Node n1 = collapseOutput(tokens.pop(), tokens);
                return new NotNode(token.getToken(), n1);
            } else if (node.token.getToken().equals(ARROW)) {
                Node n1 = collapseOutput(tokens.pop(), tokens);
                Node n2 = null;
                Node elseBranch = null;
                final Node popped = tokens.pop();
                if(popped.getToken().getToken().equals(ELSE)) {
                    elseBranch = n1;
                    n1 = collapseOutput(tokens.pop(), tokens);
                    n2 = collapseOutput(tokens.pop(), tokens);
                } else {
                    n2 = collapseOutput(popped, tokens);
                }
                return new PredicateOperatorNode(token.getToken(), n2, n1, elseBranch);
            }  else {
                return token;
            }
        } else {
            return token;
        }

    }

    private static Node parseExpression(final String string, final Token token, final Deque<Token> tokens) {
        if (token.getToken().equals(TRUE)) {
            return new OperatorNode(token);
        } else if (token.getToken().equals(FALSE)) {
            return new OperatorNode(token);
        } else {
            Token next = tokens.peek();
            String endChar = ")";
            if (next != null && (next.getToken().equals("[") || next.getToken().equals("("))) {
                if (next.getToken().equals("[")) {
                    endChar = "]";
                    UndertowLogger.ROOT_LOGGER.oldStylePredicateSyntax(string);
                }
                final Map<String, Node> values = new HashMap<>();

                tokens.poll();
                next = tokens.poll();
                if (next == null) {
                    throw error(string, string.length(), "Unexpected end of input");
                }
                if (next.getToken().equals("{")) {
                    return handleSingleArrayValue(string, token, tokens, endChar);
                }
                while (!next.getToken().equals(endChar)) {
                    Token equals = tokens.poll();
                    if (equals == null) {
                        throw error(string, string.length(), "Unexpected end of input");
                    }
                    if (!equals.getToken().equals("=")) {
                        if (equals.getToken().equals(endChar) && values.isEmpty()) {
                            //single value case
                            return handleSingleValue(token, next);
                        } else if (equals.getToken().equals(",")) {
                            tokens.push(equals);
                            tokens.push(next);
                            return handleSingleVarArgsValue(string, token, tokens, endChar);
                        }
                        throw error(string, equals.getPosition(), "Unexpected token");
                    }
                    Token value = tokens.poll();
                    if (value == null) {
                        throw error(string, string.length(), "Unexpected end of input");
                    }
                    if (value.getToken().equals("{")) {
                        values.put(next.getToken(), new ArrayNode(value, readArrayType(string, tokens,"}")));
                    } else {
                        if (isOperator(value.getToken()) || isSpecialChar(value.getToken())) {
                            throw error(string, value.getPosition(), "Unexpected token");
                        }
                        values.put(next.getToken(), new ValueNode(value));
                    }

                    next = tokens.poll();
                    if (next == null) {
                        throw error(string, string.length(), "Unexpected end of input");
                    }
                    if (!next.getToken().equals(endChar)) {
                        if (!next.getToken().equals(",")) {
                            throw error(string, string.length(), "Expecting , or " + endChar);
                        }
                        next = tokens.poll();
                        if (next == null) {
                            throw error(string, string.length(), "Unexpected end of input");
                        }
                    }
                }
                return new ExpressionNode(token, values);

            } else {
                if (next != null && isSpecialChar(next.getToken())) {
                    throw error(string, next.getPosition(), "Unexpected character");
                }
                return new ExpressionNode(token, Collections.<String, Node>emptyMap());
            }
        }
    }

    private static Node handleSingleArrayValue(final String string, final Token builder, final Deque<Token> tokens, String endChar) {
        List<Token> array = readArrayType(string, tokens, "}");
        Token close = tokens.poll();
        if (!close.getToken().equals(endChar)) {
            throw error(string, close.getPosition(), "expected " + endChar);
        }
        return new ExpressionNode(builder, Collections.<String, Node>singletonMap(null, new ArrayNode(builder, array)));
    }

    private static Node handleSingleVarArgsValue(final String string, final Token expressionName, final Deque<Token> tokens, String endChar) {
        List<Token> array = readArrayType(string, tokens, endChar);
        return new ExpressionNode(expressionName, Collections.<String, Node>singletonMap(null, new ArrayNode(expressionName, array)));
    }

    private static List<Token> readArrayType(final String string, final Deque<Token> tokens, String expectedEndToken) {
        final List<Token> values = new ArrayList<>();
        Token token = tokens.poll();
        if(token.getToken().equals(expectedEndToken)) {
            return Collections.emptyList();
        }
        while (token != null) {
            Token commaOrEnd = tokens.poll();
            values.add(token);
            if (commaOrEnd.getToken().equals(expectedEndToken)) {
                return values;
            } else if (!commaOrEnd.getToken().equals(",")) {
                throw error(string, commaOrEnd.getPosition(), "expected either , or " + expectedEndToken);
            }
            token = tokens.poll();
        }
        throw error(string, string.length(), "unexpected end of input in array");
    }


    private static Node handleSingleValue(final Token token, final Token next) {
        return new ExpressionNode(token, Collections.<String, Node>singletonMap(null, new ValueNode(next)));
    }

    private static int precedence(String operator) {
        if (operator.equals(NOT)) {
            return 3;
        } else if (operator.equals(AND)) {
            return 2;
        } else if (operator.equals(OR)) {
            return 1;
        } else if (operator.equals(ARROW)) {
            return -1000;
        }
        throw new IllegalStateException();
    }


    private static boolean isOperator(final String op) {
        return op.equals(AND) || op.equals(OR) || op.equals(NOT) || op.equals(ARROW);
    }

    private static boolean isSpecialChar(String token) {
        if (token.length() == 1) {
            char c = token.charAt(0);
            switch (c) {
                case '(':
                case ')':
                case ',':
                case '=':
                case '[':
                case ']':
                    return true;
                default:
                    return false;
            }
        }
        return false;
    }

    public static Deque<Token> tokenize(final String string) {
        char currentStringDelim = 0;
        boolean inVariable = false;

        int pos = 0;
        StringBuilder current = new StringBuilder();
        Deque<Token> ret = new ArrayDeque<>();
        while (pos < string.length()) {
            char c = string.charAt(pos);
            if (currentStringDelim != 0) {
                if (c == currentStringDelim && current.charAt(current.length() - 1) != '\\') {
                    ret.add(new Token(current.toString(), pos));
                    current.setLength(0);
                    currentStringDelim = 0;
                } else if (c == '\n') {
                    ret.add(new Token(current.toString(), pos));
                    current.setLength(0);
                    currentStringDelim = 0;
                    ret.add(new Token("\n", pos));
                } else {
                    current.append(c);
                }
            } else {
                switch (c) {
                    case ' ':
                    case '\t': {
                        if (current.length() != 0) {
                            ret.add(new Token(current.toString(), pos));
                            current.setLength(0);
                        }
                        break;
                    }
                    case '\n': {
                        if (current.length() != 0) {
                            ret.add(new Token(current.toString(), pos));
                            current.setLength(0);
                        }
                        ret.add(new Token("\n", pos));
                        break;
                    }
                    case ';':
                    case '(':
                    case ')':
                    case ',':
                    case '=':
                    case '[':
                    case ']':
                    case '{':
                    case '}': {
                        if (inVariable) {
                            current.append(c);
                            if (c == '}') {
                                inVariable = false;
                            }
                        } else {
                            if (current.length() != 0) {
                                ret.add(new Token(current.toString(), pos));
                                current.setLength(0);
                            }
                            ret.add(new Token("" + c, pos));
                        }
                        break;
                    }
                    case '"':
                    case '\'': {
                        if (current.length() != 0) {
                            throw error(string, pos, "Unexpected token");
                        }
                        currentStringDelim = c;
                        break;
                    }
                    case '%':
                    case '$': {
                        current.append(c);
                        if (string.charAt(pos + 1) == '{') {
                            inVariable = true;
                        }
                        break;
                    }
                    case '-':
                        if (inVariable) {
                            current.append(c);
                        } else {
                            if (pos != string.length() && string.charAt(pos + 1) == '>') {
                                pos++;
                                if (current.length() != 0) {
                                    ret.add(new Token(current.toString(), pos));
                                    current.setLength(0);
                                }
                                ret.add(new Token(ARROW, pos));
                            } else {
                                current.append(c);
                            }
                        }
                        break;
                    default:
                        current.append(c);
                }
            }
            ++pos;
        }
        if (current.length() > 0) {
            ret.add(new Token(current.toString(), string.length()));
        }
        return ret;
    }

    public static IllegalStateException error(final String string, int pos, String reason) {
        StringBuilder b = new StringBuilder();
        int linePos = 0;
        for (int i = 0; i < string.length(); ++i) {
            if (string.charAt(i) == '\n') {
                if (i >= pos) {
                    //truncate the string at the error line
                    break;
                } else {
                    linePos = 0;
                }
            } else if (i < pos) {
                linePos++;
            }
            b.append(string.charAt(i));
        }
        b.append('\n');
        for (int i = 0; i < linePos; ++i) {
            b.append(' ');
        }
        b.append('^');
        throw UndertowMessages.MESSAGES.errorParsingPredicateString(reason, b.toString());
    }

    public interface Node {

        Token getToken();

    }


    /**
     * A parsed expression
     */
    static class ExpressionNode implements Node {

        private final Token token;
        private final Map<String, Node> values;

        private ExpressionNode(Token token, Map<String, Node> values) {
            this.token = token;
            this.values = values;
        }

        public Token getToken() {
            return token;
        }

        public Map<String, Node> getValues() {
            return values;
        }
    }

    static class ArrayNode implements Node {
        private final Token start;
        private final List<Token> values;

        private ArrayNode(Token start, List<Token> tokens) {
            this.start = start;
            this.values = tokens;
        }

        public List<Token> getValues() {
            return values;
        }

        @Override
        public Token getToken() {
            return start;
        }
    }

    static class ValueNode implements Node {
        private final Token value;

        private ValueNode(Token value) {
            this.value = value;
        }

        public Token getValue() {
            return value;
        }

        @Override
        public String toString() {
            return value.getToken();
        }

        @Override
        public Token getToken() {
            return value;
        }
    }

    static class OperatorNode implements Node {

        private final Token token;

        private OperatorNode(Token token) {
            this.token = token;
        }

        public Token getToken() {
            return token;
        }
    }


    static class AndNode implements Node {
        private final Token token;
        private final Node left;
        private final Node right;

        public AndNode(Token token, Node left, Node right) {
            this.token = token;
            this.left = left;
            this.right = right;
        }

        public Node getLeft() {
            return left;
        }

        public Node getRight() {
            return right;
        }

        public Token getToken() {
            return token;
        }
    }

    static class OrNode implements Node {
        private final Token token;
        private final Node left;
        private final Node right;

        public OrNode(Token token, Node left, Node right) {
            this.token = token;
            this.left = left;
            this.right = right;
        }

        public Node getLeft() {
            return left;
        }

        public Node getRight() {
            return right;
        }

        public Token getToken() {
            return token;
        }
    }


    static class PredicateOperatorNode implements Node {
        private final Token token;
        private final Node left;
        private final Node right;
        private final Node elseBranch;

        public PredicateOperatorNode(Token token, Node left, Node right, Node elseBranch) {
            this.token = token;
            this.left = left;
            this.right = right;
            this.elseBranch = elseBranch;
        }

        public Node getLeft() {
            return left;
        }

        public Node getRight() {
            return right;
        }

        public Node getElseBranch() {
            return elseBranch;
        }

        @Override
        public Token getToken() {
            return token;
        }
    }

    static class NotNode implements Node {

        private final Token token;
        private final Node node;

        public NotNode(Token token, Node node) {
            this.token = token;
            this.node = node;
        }

        public Node getNode() {
            return node;
        }

        public Token getToken() {
            return token;
        }
    }

    static class BlockNode implements Node {
        private final Token token;
        private final List<Node> block;

        public BlockNode(Token token, List<Node> block) {
            this.token = token;
            this.block = block;
        }

        public List<Node> getBlock() {
            return block;
        }

        @Override
        public Token getToken() {
            return token;
        }
    }


    static final class Token {
        private final String token;
        private final int position;

        public Token(final String token, final int position) {
            this.token = token;
            this.position = position;
        }

        public String getToken() {
            return token;
        }

        public int getPosition() {
            return position;
        }

        @Override
        public String toString() {
            return token + " <" + position + ">";
        }
    }
}


File: core/src/test/java/io/undertow/server/handlers/PredicatedHandlersTestCase.java
/*
 * JBoss, Home of Professional Open Source.
 * Copyright 2014 Red Hat, Inc., and individual contributors
 * as indicated by the @author tags.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package io.undertow.server.handlers;

import io.undertow.Handlers;
import io.undertow.server.HttpHandler;
import io.undertow.server.HttpServerExchange;
import io.undertow.server.handlers.builder.PredicatedHandlersParser;
import io.undertow.testutils.DefaultServer;
import io.undertow.testutils.HttpClientUtils;
import io.undertow.testutils.TestHttpClient;
import io.undertow.util.StatusCodes;
import org.apache.http.HttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.junit.Assert;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.io.IOException;

/**
 * @author Stuart Douglas
 */
@RunWith(DefaultServer.class)
public class PredicatedHandlersTestCase {

    @Test
    public void testRewrite() throws IOException {
        DefaultServer.setRootHandler(
                Handlers.predicates(

                        PredicatedHandlersParser.parse(
                                        "path(/skipallrules) and true -> done\n" +
                                        "method(GET) -> set(attribute='%{o,type}', value=get) \n" +
                                        "regex('(.*).css') -> {rewrite['${1}.xcss'];set(attribute='%{o,chained}', value=true)} \n" +
                                        "regex('(.*).redirect$') -> redirect['${1}.redirected']\n" +
                                        "set[attribute='%{o,someHeader}', value=always]\n" +
                                        "path-template('/foo/{bar}/{f}') -> set[attribute='%{o,template}', value='${bar}']\n" +
                                        "path-template('/bar->foo') -> redirect(/);" +
                                        "regex('(.*).css') -> set[attribute='%{o,css}', value='true'] else set[attribute='%{o,css}', value='false']; " +
                                        "path(/restart) -> {rewrite(/foo/a/b); restart; }", getClass().getClassLoader()), new HttpHandler() {
                            @Override
                            public void handleRequest(HttpServerExchange exchange) throws Exception {
                                exchange.getResponseSender().send(exchange.getRelativePath());
                            }
                        }));

        TestHttpClient client = new TestHttpClient();
        try {
            HttpGet get = new HttpGet(DefaultServer.getDefaultServerURL() + "/foo/a/b");
            HttpResponse result = client.execute(get);
            Assert.assertEquals(StatusCodes.OK, result.getStatusLine().getStatusCode());
            String response = HttpClientUtils.readResponse(result);
            Assert.assertEquals("get", result.getHeaders("type")[0].getValue());
            Assert.assertEquals("always", result.getHeaders("someHeader")[0].getValue());
            Assert.assertEquals("a", result.getHeaders("template")[0].getValue());
            Assert.assertEquals("false", result.getHeaders("css")[0].getValue());
            Assert.assertEquals("/foo/a/b", response);

            get = new HttpGet(DefaultServer.getDefaultServerURL() + "/foo/a/b.css");
            result = client.execute(get);
            Assert.assertEquals(StatusCodes.OK, result.getStatusLine().getStatusCode());
            response = HttpClientUtils.readResponse(result);
            Assert.assertEquals("get", result.getHeaders("type")[0].getValue());
            Assert.assertEquals("true", result.getHeaders("chained")[0].getValue());
            Assert.assertEquals("/foo/a/b.xcss", response);
            Assert.assertEquals("always", result.getHeaders("someHeader")[0].getValue());
            Assert.assertEquals("true", result.getHeaders("css")[0].getValue());
            Assert.assertEquals("a", result.getHeaders("template")[0].getValue());

            get = new HttpGet(DefaultServer.getDefaultServerURL() + "/foo/a/b.redirect");
            result = client.execute(get);
            Assert.assertEquals(StatusCodes.OK, result.getStatusLine().getStatusCode());
            response = HttpClientUtils.readResponse(result);
            Assert.assertEquals("get", result.getHeaders("type")[0].getValue());
            Assert.assertEquals("always", result.getHeaders("someHeader")[0].getValue());
            Assert.assertEquals("a", result.getHeaders("template")[0].getValue());
            Assert.assertEquals("/foo/a/b.redirected", response);


            get = new HttpGet(DefaultServer.getDefaultServerURL() + "/skipallrules");
            result = client.execute(get);
            Assert.assertEquals(StatusCodes.OK, result.getStatusLine().getStatusCode());
            response = HttpClientUtils.readResponse(result);
            Assert.assertEquals(0, result.getHeaders("someHeader").length);

            get = new HttpGet(DefaultServer.getDefaultServerURL() + "/restart");
            result = client.execute(get);
            Assert.assertEquals(StatusCodes.OK, result.getStatusLine().getStatusCode());
            response = HttpClientUtils.readResponse(result);
            Assert.assertEquals("get", result.getHeaders("type")[0].getValue());
            Assert.assertEquals("always", result.getHeaders("someHeader")[0].getValue());
            Assert.assertEquals("a", result.getHeaders("template")[0].getValue());
            Assert.assertEquals("/foo/a/b", response);
        } finally {
            client.getConnectionManager().shutdown();
        }
    }

}


File: core/src/test/java/io/undertow/server/handlers/builder/PredicatedHandlersParserTestCase.java
/*
 * JBoss, Home of Professional Open Source.
 * Copyright 2014 Red Hat, Inc., and individual contributors
 * as indicated by the @author tags.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package io.undertow.server.handlers.builder;

import io.undertow.predicate.ContainsPredicate;
import io.undertow.server.HttpHandler;
import io.undertow.server.handlers.AllowedMethodsHandler;
import io.undertow.server.handlers.RequestDumpingHandler;
import io.undertow.server.handlers.ResponseCodeHandler;
import io.undertow.server.handlers.SetHeaderHandler;
import io.undertow.server.handlers.builder.PredicatedHandlersParser.BlockNode;
import io.undertow.server.handlers.builder.PredicatedHandlersParser.Node;
import io.undertow.server.handlers.builder.PredicatedHandlersParser.PredicateOperatorNode;
import io.undertow.util.HttpString;
import org.junit.Assert;
import org.junit.Test;

import java.util.Arrays;
import java.util.HashSet;
import java.util.List;

/**
 * @author Stuart Douglas
 */
public class PredicatedHandlersParserTestCase {

    @Test
    public void testAstRepresentation1() {
        String value = "path(/foo) -> rewrite(/bar)";
        Node node = PredicatedHandlersParser.parse(value, PredicatedHandlersParser.tokenize(value));
        Assert.assertTrue(node instanceof PredicateOperatorNode);
        PredicateOperatorNode op = (PredicateOperatorNode) node;
        Assert.assertEquals("->", op.getToken().getToken());
        Assert.assertEquals("path", op.getLeft().getToken().getToken());
        Assert.assertEquals("/foo", ((PredicatedHandlersParser.ExpressionNode) op.getLeft()).getValues().get(null).toString());
    }

    @Test
    public void testAstRepresentation2() {
        String value = "path(/foo) -> rewrite(/bar)\npath(/foo) -> rewrite(/bar)";
        Node node = PredicatedHandlersParser.parse(value, PredicatedHandlersParser.tokenize(value));
        Assert.assertTrue(node instanceof BlockNode);
        BlockNode block = (BlockNode) node;
        PredicateOperatorNode op = (PredicateOperatorNode) block.getBlock().get(1);
        Assert.assertEquals("->", op.getToken().getToken());
        Assert.assertEquals("path", op.getLeft().getToken().getToken());
        Assert.assertEquals("/foo", ((PredicatedHandlersParser.ExpressionNode) op.getLeft()).getValues().get(null).toString());
    }

    @Test
    public void testAstRepresentation3() {
        String value = "path(/foo) -> { rewrite(/bar); path(/x) -> rewrite(/x)}";
        Node node = PredicatedHandlersParser.parse(value, PredicatedHandlersParser.tokenize(value));
        Assert.assertTrue(node instanceof PredicateOperatorNode);

        PredicateOperatorNode op = (PredicateOperatorNode) node;
        Assert.assertEquals("->", op.getToken().getToken());
        Assert.assertEquals("path", op.getLeft().getToken().getToken());
        Assert.assertEquals("/foo", ((PredicatedHandlersParser.ExpressionNode) op.getLeft()).getValues().get(null).toString());

        BlockNode block = (BlockNode) op.getRight();
        op = (PredicateOperatorNode) block.getBlock().get(1);
        Assert.assertEquals("->", op.getToken().getToken());
        Assert.assertEquals("path", op.getLeft().getToken().getToken());
        Assert.assertEquals("/x", ((PredicatedHandlersParser.ExpressionNode) op.getLeft()).getValues().get(null).toString());
    }


    @Test
    public void testParsedHandler1() {
        String value = "dump-request";
        List<PredicatedHandler> ret = PredicatedHandlersParser.parse(value, getClass().getClassLoader());
        Assert.assertEquals(1, ret.size());
        HttpHandler handler = ret.get(0).getHandler().wrap(ResponseCodeHandler.HANDLE_200);
        Assert.assertTrue(handler instanceof RequestDumpingHandler);
    }

    @Test
    public void testParsedHandler2() {
        String value = "header(header=a, value='b')";
        List<PredicatedHandler> ret = PredicatedHandlersParser.parse(value, getClass().getClassLoader());
        Assert.assertEquals(1, ret.size());
        SetHeaderHandler handler = (SetHeaderHandler) ret.get(0).getHandler().wrap(ResponseCodeHandler.HANDLE_200);
        Assert.assertEquals("a", handler.getHeader().toString());
        Assert.assertEquals("b", handler.getValue().readAttribute(null));
    }

    @Test
    public void testParsedHandler3() {
        String value = "allowed-methods(GET)";
        List<PredicatedHandler> ret = PredicatedHandlersParser.parse(value, getClass().getClassLoader());
        Assert.assertEquals(1, ret.size());
        AllowedMethodsHandler handler = (AllowedMethodsHandler) ret.get(0).getHandler().wrap(ResponseCodeHandler.HANDLE_200);
        Assert.assertEquals(new HashSet<>(Arrays.asList(HttpString.tryFromString("GET"))), handler.getAllowedMethods());

        value = "allowed-methods(methods=GET)";
        ret = PredicatedHandlersParser.parse(value, getClass().getClassLoader());
        Assert.assertEquals(1, ret.size());
        handler = (AllowedMethodsHandler) ret.get(0).getHandler().wrap(ResponseCodeHandler.HANDLE_200);
        Assert.assertEquals(new HashSet<>(Arrays.asList(HttpString.tryFromString("GET"))), handler.getAllowedMethods());

        value = "allowed-methods(methods={GET})";
        ret = PredicatedHandlersParser.parse(value, getClass().getClassLoader());
        Assert.assertEquals(1, ret.size());
        handler = (AllowedMethodsHandler) ret.get(0).getHandler().wrap(ResponseCodeHandler.HANDLE_200);
        Assert.assertEquals(new HashSet<>(Arrays.asList(HttpString.tryFromString("GET"))), handler.getAllowedMethods());

        value = "allowed-methods({GET})";
        ret = PredicatedHandlersParser.parse(value, getClass().getClassLoader());
        Assert.assertEquals(1, ret.size());
        handler = (AllowedMethodsHandler) ret.get(0).getHandler().wrap(ResponseCodeHandler.HANDLE_200);
        Assert.assertEquals(new HashSet<>(Arrays.asList(HttpString.tryFromString("GET"))), handler.getAllowedMethods());


        value = "allowed-methods({GET, POST})";
        ret = PredicatedHandlersParser.parse(value, getClass().getClassLoader());
        Assert.assertEquals(1, ret.size());
        handler = (AllowedMethodsHandler) ret.get(0).getHandler().wrap(ResponseCodeHandler.HANDLE_200);
        Assert.assertEquals(new HashSet<>(Arrays.asList(HttpString.tryFromString("GET"), HttpString.tryFromString("POST"))), handler.getAllowedMethods());

        value = "allowed-methods(methods={GET, POST})";
        ret = PredicatedHandlersParser.parse(value, getClass().getClassLoader());
        Assert.assertEquals(1, ret.size());
        handler = (AllowedMethodsHandler) ret.get(0).getHandler().wrap(ResponseCodeHandler.HANDLE_200);
        Assert.assertEquals(new HashSet<>(Arrays.asList(HttpString.tryFromString("GET"), HttpString.tryFromString("POST"))), handler.getAllowedMethods());

        value = "allowed-methods(GET, POST)";
        ret = PredicatedHandlersParser.parse(value, getClass().getClassLoader());
        Assert.assertEquals(1, ret.size());
        handler = (AllowedMethodsHandler) ret.get(0).getHandler().wrap(ResponseCodeHandler.HANDLE_200);
        Assert.assertEquals(new HashSet<>(Arrays.asList(HttpString.tryFromString("GET"), HttpString.tryFromString("POST"))), handler.getAllowedMethods());
    }


    @Test
    public void testParsedPredicatedHandler1() {
        String value = "contains(value='a', search=b) -> dump-request";
        List<PredicatedHandler> ret = PredicatedHandlersParser.parse(value, getClass().getClassLoader());
        Assert.assertEquals(1, ret.size());
        HttpHandler handler = ret.get(0).getHandler().wrap(ResponseCodeHandler.HANDLE_200);
        Assert.assertTrue(handler instanceof RequestDumpingHandler);

        ContainsPredicate predicate = (ContainsPredicate) ret.get(0).getPredicate();
        Assert.assertEquals("a", predicate.getAttribute().readAttribute(null));
        Assert.assertArrayEquals(new String[]{"b"}, predicate.getValues());

        value = "contains(value='a', search={b}) -> dump-request";
        ret = PredicatedHandlersParser.parse(value, getClass().getClassLoader());
        Assert.assertEquals(1, ret.size());
        handler = ret.get(0).getHandler().wrap(ResponseCodeHandler.HANDLE_200);
        Assert.assertTrue(handler instanceof RequestDumpingHandler);

        predicate = (ContainsPredicate) ret.get(0).getPredicate();
        Assert.assertEquals("a", predicate.getAttribute().readAttribute(null));
        Assert.assertArrayEquals(new String[]{"b"}, predicate.getValues());

        value = "contains[value='a', search={b, c}] -> dump-request";
        ret = PredicatedHandlersParser.parse(value, getClass().getClassLoader());
        Assert.assertEquals(1, ret.size());
        handler = ret.get(0).getHandler().wrap(ResponseCodeHandler.HANDLE_200);
        Assert.assertTrue(handler instanceof RequestDumpingHandler);

        predicate = (ContainsPredicate) ret.get(0).getPredicate();
        Assert.assertEquals("a", predicate.getAttribute().readAttribute(null));
        Assert.assertArrayEquals(new String[]{"b", "c"}, predicate.getValues());
    }

}
