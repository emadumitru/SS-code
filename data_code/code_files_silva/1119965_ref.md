

File: eureka2-integration/src/main/java/com/netflix/eureka2/integration/EurekaDeploymentClients.java
package com.netflix.eureka2.integration;

import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

import com.netflix.eureka2.interests.ChangeNotification;
import com.netflix.eureka2.interests.ChangeNotification.Kind;
import com.netflix.eureka2.interests.Interests;
import com.netflix.eureka2.registry.Source;
import com.netflix.eureka2.registry.Source.Origin;
import com.netflix.eureka2.registry.SourcedEurekaRegistry;
import com.netflix.eureka2.registry.instance.InstanceInfo;
import com.netflix.eureka2.testkit.embedded.EurekaDeployment;
import com.netflix.eureka2.testkit.embedded.server.EmbeddedWriteServer;
import com.netflix.eureka2.utils.rx.NoOpSubscriber;
import rx.functions.Action1;

import static com.netflix.eureka2.testkit.data.builder.SampleInstanceInfo.collectionOf;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

/**
 * This is client side counterpart of {@link EurekaDeployment} class,
 * which provides easy means for injecting/verifying large amount of data into/out of the Eureka cluster.
 * This is handy for more complex integration tests.
 *
 * @author Tomasz Bak
 */
public class EurekaDeploymentClients {

    private static final int TIMEOUT_SEC = 30;

    private final EurekaDeployment eurekaDeployment;

    public EurekaDeploymentClients(EurekaDeployment eurekaDeployment) {
        this.eurekaDeployment = eurekaDeployment;
    }

    public void fillUpRegistryOfServer(int serverIdx, int count, InstanceInfo instanceTemplate) throws Exception {
        Iterator<InstanceInfo> instanceIt = collectionOf(instanceTemplate.getApp(), instanceTemplate);
        Source source = new Source(Origin.LOCAL, "write" + serverIdx);
        SourcedEurekaRegistry<InstanceInfo> eurekaServerRegistry = eurekaDeployment.getWriteCluster().getServer(serverIdx).getEurekaServerRegistry();

        final Set<String> expectedInstances = new HashSet<>();
        for (int i = 0; i < count; i++) {
            InstanceInfo next = instanceIt.next();
            eurekaServerRegistry.register(next, source).subscribe(new NoOpSubscriber<Boolean>());
            expectedInstances.add(next.getId());
        }

        final CountDownLatch latch = new CountDownLatch(expectedInstances.size());

        eurekaServerRegistry.forInterest(Interests.forApplications(instanceTemplate.getApp()))
                .subscribe(new Action1<ChangeNotification<InstanceInfo>>() {
                    @Override
                    public void call(ChangeNotification<InstanceInfo> notification) {
                        if (notification.getKind() == Kind.Add) {
                            String id = notification.getData().getId();
                            if (expectedInstances.remove(id)) {
                                latch.countDown();
                            }
                        }
                    }
                });

        assertTrue("Registry not ready in time", latch.await(30, TimeUnit.SECONDS));
    }

    public void fillUpRegistry(int count, InstanceInfo instanceTemplate) throws Exception {
        fillUpRegistryOfServer(0, count, instanceTemplate);
    }

    public void verifyWriteServerRegistryContent(int writeServerIdx, String appName, int count) throws InterruptedException {
        SourcedEurekaRegistry<InstanceInfo> registry = registryOf(writeServerIdx);

        final CountDownLatch latch = new CountDownLatch(count);

        registry.forInterest(Interests.forApplications(appName))
                .subscribe(new Action1<ChangeNotification<InstanceInfo>>() {
                    @Override
                    public void call(ChangeNotification<InstanceInfo> notification) {
                        if (notification.getKind() == Kind.Add) {
                            latch.countDown();
                        }
                    }
                });

        assertTrue("Registry not ready in time", latch.await(TIMEOUT_SEC, TimeUnit.SECONDS));
    }

    public void verifyWriteServerHasNoInstance(int writeServerIdx, String appName) throws InterruptedException {
        SourcedEurekaRegistry<InstanceInfo> registry = registryOf(writeServerIdx);

        final CountDownLatch latch = new CountDownLatch(1);

        /**
         * TODO We cannot trust buffer markers yet, so we subscribe and wait for some time to be sure there is no data for the given app
         */
        registry.forInterest(Interests.forApplications(appName))
                .subscribe(new Action1<ChangeNotification<InstanceInfo>>() {
                    @Override
                    public void call(ChangeNotification<InstanceInfo> notification) {
                        if (notification.getKind() == Kind.Add) {
                            latch.countDown();
                        }
                    }
                });
        assertFalse("Unexpected items in the registry found", latch.await(1, TimeUnit.SECONDS));
    }

    private SourcedEurekaRegistry<InstanceInfo> registryOf(int writeServerIdx) {
        EmbeddedWriteServer server = eurekaDeployment.getWriteCluster().getServer(writeServerIdx);
        return server.getEurekaServerRegistry();
    }
}


File: eureka2-integration/src/test/java/com/netflix/eureka2/integration/client/EurekaClientFailoverTest.java
package com.netflix.eureka2.integration.client;

import java.util.concurrent.TimeUnit;

import com.netflix.eureka2.client.EurekaInterestClient;
import com.netflix.eureka2.client.EurekaRegistrationClient;
import com.netflix.eureka2.interests.ChangeNotification;
import com.netflix.eureka2.interests.Interest.Operator;
import com.netflix.eureka2.interests.Interests;
import com.netflix.eureka2.junit.categories.IntegrationTest;
import com.netflix.eureka2.registry.instance.InstanceInfo;
import com.netflix.eureka2.registry.instance.InstanceInfo.Status;
import com.netflix.eureka2.rx.ExtTestSubscriber;
import com.netflix.eureka2.testkit.data.builder.SampleInstanceInfo;
import com.netflix.eureka2.testkit.embedded.cluster.EmbeddedReadCluster;
import com.netflix.eureka2.testkit.embedded.cluster.EmbeddedWriteCluster;
import com.netflix.eureka2.testkit.junit.resources.EurekaDeploymentResource;
import com.netflix.eureka2.testkit.netrouter.NetworkLink;
import com.netflix.eureka2.testkit.netrouter.NetworkRouter;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.experimental.categories.Category;
import rx.Subscription;
import rx.subjects.PublishSubject;

import static com.netflix.eureka2.interests.ChangeNotifications.dataOnlyFilter;
import static com.netflix.eureka2.testkit.junit.EurekaMatchers.addChangeNotificationOf;
import static com.netflix.eureka2.testkit.junit.EurekaMatchers.modifyChangeNotificationOf;
import static com.netflix.eureka2.testkit.junit.resources.EurekaDeploymentResource.anEurekaDeploymentResource;
import static org.hamcrest.Matchers.is;
import static org.junit.Assert.assertThat;

/**
 * @author Tomasz Bak
 */
@Category(IntegrationTest.class)
public class EurekaClientFailoverTest {

    private static final InstanceInfo INSTANCE_UP = SampleInstanceInfo.WebServer.build();
    private static final InstanceInfo INSTANCE_DOWN = new InstanceInfo.Builder().withInstanceInfo(INSTANCE_UP).withStatus(Status.DOWN).build();

    @Rule
    public final EurekaDeploymentResource eurekaDeploymentResource =
            anEurekaDeploymentResource(1, 1).withNetworkRouter(true).build();

    private NetworkRouter networkRouter;
    private EmbeddedWriteCluster writeCluster;
    private EmbeddedReadCluster readCluster;

    @Before
    public void setUp() throws Exception {
        networkRouter = eurekaDeploymentResource.getEurekaDeployment().getNetworkRouter();
        writeCluster = eurekaDeploymentResource.getEurekaDeployment().getWriteCluster();
        readCluster = eurekaDeploymentResource.getEurekaDeployment().getReadCluster();
    }

    @Test
    public void testRegistrationFailover() throws Exception {
        executeFailoverTest(new Runnable() {
            @Override
            public void run() {
                // Scale the write cluster up, and break network connection to the first node
                writeCluster.scaleUpByOne();
                NetworkLink registrationLink = networkRouter.getLinkTo(writeCluster.getServer(0).getRegistrationPort());
                NetworkLink interestLink = networkRouter.getLinkTo(writeCluster.getServer(0).getDiscoveryPort());
                NetworkLink replicationLink = networkRouter.getLinkTo(writeCluster.getServer(0).getReplicationPort());
                registrationLink.disconnect();
                interestLink.disconnect();
                replicationLink.disconnect();
            }
        });
    }

    @Test
    public void testInterestFailover() throws Exception {
        executeFailoverTest(new Runnable() {
            @Override
            public void run() {
                // Scale the read cluster up, and break the network connection to the first read server
                readCluster.scaleUpByOne();
                NetworkLink networkLink = networkRouter.getLinkTo(readCluster.getServer(0).getDiscoveryPort());
                networkLink.disconnect();
            }
        });
    }

    private void executeFailoverTest(Runnable failureInjector) throws Exception {
        // Subscribe to instance registration updates
        ExtTestSubscriber<ChangeNotification<InstanceInfo>> interestSubscriber = subscribeTo(INSTANCE_UP);

        // Register
        PublishSubject<InstanceInfo> registrationSubject = PublishSubject.create();
        EurekaRegistrationClient registrationClient = eurekaDeploymentResource.getEurekaDeployment().registrationClientToWriteCluster();
        Subscription registrationSubscription = registrationClient.register(registrationSubject).subscribe();
        registrationSubject.onNext(INSTANCE_UP);

        assertThat(interestSubscriber.takeNext(60, TimeUnit.SECONDS), is(addChangeNotificationOf(INSTANCE_UP)));

        // Inject failure
        failureInjector.run();

        // Update instance status, and verify that it was handled
        registrationSubject.onNext(INSTANCE_DOWN);

        assertThat(registrationSubscription.isUnsubscribed(), is(false));
        assertThat(interestSubscriber.takeNext(60, TimeUnit.SECONDS), is(modifyChangeNotificationOf(INSTANCE_DOWN)));
    }

    private ExtTestSubscriber<ChangeNotification<InstanceInfo>> subscribeTo(InstanceInfo instanceInfo) {
        EurekaInterestClient interestClient = eurekaDeploymentResource.getEurekaDeployment().cannonicalInterestClient();
        ExtTestSubscriber<ChangeNotification<InstanceInfo>> interestSubscriber = new ExtTestSubscriber<>();
        interestClient.forInterest(Interests.forInstance(Operator.Equals, instanceInfo.getId()))
                .filter(dataOnlyFilter())
                .subscribe(interestSubscriber);
        return interestSubscriber;
    }
}


File: eureka2-integration/src/test/java/com/netflix/eureka2/integration/server/batching/ReadServerNotificationBatchingTest.java
package com.netflix.eureka2.integration.server.batching;

import java.util.Set;

import com.netflix.eureka2.client.EurekaInterestClient;
import com.netflix.eureka2.client.functions.InterestFunctions;
import com.netflix.eureka2.integration.EurekaDeploymentClients;
import com.netflix.eureka2.interests.ChangeNotification;
import com.netflix.eureka2.interests.Interests;
import com.netflix.eureka2.junit.categories.ExperimentalTest;
import com.netflix.eureka2.junit.categories.IntegrationTest;
import com.netflix.eureka2.registry.instance.InstanceInfo;
import com.netflix.eureka2.rx.ExtTestSubscriber;
import com.netflix.eureka2.testkit.data.builder.SampleInstanceInfo;
import com.netflix.eureka2.testkit.junit.resources.EurekaDeploymentResource;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.experimental.categories.Category;
import rx.functions.Action1;

import static com.netflix.eureka2.interests.ChangeNotifications.dataOnlyFilter;
import static org.hamcrest.Matchers.equalTo;
import static org.hamcrest.Matchers.greaterThan;
import static org.hamcrest.Matchers.is;
import static org.junit.Assert.assertThat;

/**
 * @author David Liu
 */
@Category({IntegrationTest.class, ExperimentalTest.class})
public class ReadServerNotificationBatchingTest {

    private static final int REGISTRY_INITIAL_SIZE = 100;

    /**
     * We start with single write server, and scale read cluster up later, once write server has data in
     * the registry.
     */
    @Rule
    public final EurekaDeploymentResource eurekaDeploymentResource = new EurekaDeploymentResource(1, 0);

    private EurekaDeploymentClients eurekaDeploymentClients;

    @Before
    public void setUp() throws Exception {
        eurekaDeploymentClients = new EurekaDeploymentClients(eurekaDeploymentResource.getEurekaDeployment());
    }

    /**
     * Subscribe to Eureka read server, that has not uploaded yet initial content
     * from write server. Write server batching markers shell be propagated to the client
     * and a client should get all data followed by single buffer sentinel.
     */
    @Test(timeout = 60000)
    public void testColdReadCacheDataBatching() throws Exception {
        eurekaDeploymentClients.fillUpRegistry(REGISTRY_INITIAL_SIZE, SampleInstanceInfo.WebServer.build());

        // Bootstrap read server and connect Eureka client immediately
        eurekaDeploymentResource.getEurekaDeployment().getReadCluster().scaleUpByOne();
        EurekaInterestClient eurekaClient = eurekaDeploymentResource.interestClientToReadCluster();

        ExtTestSubscriber<Set<InstanceInfo>> testSubscriber = new ExtTestSubscriber<>();
        eurekaClient.forInterest(Interests.forFullRegistry())
                .doOnNext(DELAY_ACTION)
                .compose(InterestFunctions.buffers())
                .compose(InterestFunctions.snapshots())
                .subscribe(testSubscriber);

        // We should always get in the first batch all entries
        Set<InstanceInfo> initialSet = testSubscriber.takeNextOrWait();
        assertThat(initialSet.size(), is(greaterThan(REGISTRY_INITIAL_SIZE)));
    }

    /**
     * Subscribe to Eureka read server, that has all data in its own registry.
     * Read server registry batching markers shell be propagated to the client
     * and a client should get all data followed by single buffer sentinel.
     */
    @Test(timeout = 60000)
    public void testHotCacheDataBatching() throws Exception {
        // Bootstrap read server and connect Eureka client immediately
        eurekaDeploymentResource.getEurekaDeployment().getReadCluster().scaleUpByOne();
        EurekaInterestClient eurekaClient = eurekaDeploymentResource.interestClientToReadCluster();

        // Fill in the registry
        eurekaDeploymentClients.fillUpRegistry(REGISTRY_INITIAL_SIZE, SampleInstanceInfo.WebServer.build());

        // Connect with a client and take all entries, to be sure that read server registry is hot
        ExtTestSubscriber<ChangeNotification<InstanceInfo>> testSubscriber = new ExtTestSubscriber<>();
        eurekaClient.forInterest(Interests.forFullRegistry()).filter(dataOnlyFilter()).subscribe(testSubscriber);
        testSubscriber.takeNextOrWait(REGISTRY_INITIAL_SIZE + 2);
        eurekaClient.shutdown();

        // Now connect again
        eurekaClient = eurekaDeploymentResource.interestClientToReadCluster();
        testSubscriber = new ExtTestSubscriber<>();
        eurekaClient.forInterest(Interests.forFullRegistry()).subscribe(testSubscriber);
        testSubscriber.takeNextOrWait(REGISTRY_INITIAL_SIZE + 2);

        ExtTestSubscriber<Set<InstanceInfo>> snapshotSubscriber = new ExtTestSubscriber<>();
        eurekaClient.forInterest(Interests.forFullRegistry())
                .doOnNext(DELAY_ACTION)
                .compose(InterestFunctions.buffers())
                .compose(InterestFunctions.snapshots())
                .subscribe(snapshotSubscriber);

        // We should always get in the first batch all entries
        Set<InstanceInfo> initialSet = snapshotSubscriber.takeNextOrWait();
        assertThat(initialSet.size(), is(equalTo(REGISTRY_INITIAL_SIZE + 2)));
    }

    private static final Action1<ChangeNotification<InstanceInfo>> DELAY_ACTION = new Action1<ChangeNotification<InstanceInfo>>() {
        @Override
        public void call(ChangeNotification<InstanceInfo> notification) {
            // Inject processing delay, to help expose potential batch marker races.
            try {
                Thread.sleep(1);
            } catch (InterruptedException ignore) {
            }
        }
    };
}


File: eureka2-integration/src/test/java/com/netflix/eureka2/integration/server/batching/WriteServerNotificationBatchingTest.java
package com.netflix.eureka2.integration.server.batching;

import java.util.LinkedHashSet;
import java.util.concurrent.TimeUnit;

import com.netflix.eureka2.client.EurekaInterestClient;
import com.netflix.eureka2.client.functions.InterestFunctions;
import com.netflix.eureka2.integration.EurekaDeploymentClients;
import com.netflix.eureka2.interests.ChangeNotification;
import com.netflix.eureka2.interests.Interests;
import com.netflix.eureka2.junit.categories.ExperimentalTest;
import com.netflix.eureka2.junit.categories.IntegrationTest;
import com.netflix.eureka2.registry.instance.InstanceInfo;
import com.netflix.eureka2.testkit.data.builder.SampleInstanceInfo;
import com.netflix.eureka2.testkit.junit.resources.EurekaDeploymentResource;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.experimental.categories.Category;
import rx.functions.Action1;

import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.equalTo;
import static org.hamcrest.Matchers.is;

/**
 * @author Tomasz Bak
 */
@Category({IntegrationTest.class, ExperimentalTest.class})
public class WriteServerNotificationBatchingTest {

    private static final int CLUSTER_SIZE = 50;

    @Rule
    public final EurekaDeploymentResource eurekaDeploymentResource = new EurekaDeploymentResource(2, 0);

    private EurekaDeploymentClients eurekaDeploymentClients;

    @Before
    public void setUp() throws Exception {
        eurekaDeploymentClients = new EurekaDeploymentClients(eurekaDeploymentResource.getEurekaDeployment());
    }

    @Test
    public void testWriteServerReturnsAvailableContentAsOneBatch() throws Exception {
        EurekaInterestClient subscriberClient = eurekaDeploymentResource.interestClientToWriteServer(0);

        InstanceInfo instanceTemplate = SampleInstanceInfo.WebServer.build();
        eurekaDeploymentClients.fillUpRegistry(CLUSTER_SIZE, instanceTemplate);

        LinkedHashSet<InstanceInfo> batch = subscriberClient.forInterest(Interests.forApplications(instanceTemplate.getApp()))
                .doOnNext(new Action1<ChangeNotification<InstanceInfo>>() {
                    @Override
                    public void call(ChangeNotification<InstanceInfo> notification) {
                        // Inject processing delay, to help expose potential batch marker races.
                        try {
                            Thread.sleep(1);
                        } catch (InterruptedException ignore) {
                        }
                    }
                })
                .compose(InterestFunctions.buffers())
                .compose(InterestFunctions.snapshots())
                .take(1)
                .timeout(30, TimeUnit.SECONDS)
                .toBlocking()
                .first();

        assertThat(batch.size(), is(equalTo(CLUSTER_SIZE)));
    }
}


File: eureka2-integration/src/test/java/com/netflix/eureka2/integration/server/interest/ReadWriteClusterIntegrationTest.java
package com.netflix.eureka2.integration.server.interest;

import com.netflix.eureka2.client.EurekaInterestClient;
import com.netflix.eureka2.client.EurekaRegistrationClient;
import com.netflix.eureka2.interests.ChangeNotification;
import com.netflix.eureka2.interests.Interests;
import com.netflix.eureka2.junit.categories.IntegrationTest;
import com.netflix.eureka2.registry.instance.InstanceInfo;
import com.netflix.eureka2.rx.ExtTestSubscriber;
import com.netflix.eureka2.testkit.data.builder.SampleInstanceInfo;
import com.netflix.eureka2.testkit.embedded.EurekaDeployment;
import com.netflix.eureka2.testkit.junit.resources.EurekaDeploymentResource;
import com.netflix.eureka2.testkit.netrouter.NetworkLink;
import org.junit.After;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.experimental.categories.Category;
import rx.Observable;
import rx.Subscription;

import static com.netflix.eureka2.interests.ChangeNotifications.dataOnlyFilter;
import static com.netflix.eureka2.testkit.junit.EurekaMatchers.addChangeNotificationOf;
import static com.netflix.eureka2.testkit.junit.EurekaMatchers.deleteChangeNotificationOf;
import static com.netflix.eureka2.testkit.junit.resources.EurekaDeploymentResource.anEurekaDeploymentResource;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.is;

/**
 * @author David Liu
 */
@Category(IntegrationTest.class)
public class ReadWriteClusterIntegrationTest {

    @Rule
    public final EurekaDeploymentResource eurekaDeploymentResource =
            anEurekaDeploymentResource(1, 1).withNetworkRouter(true).build();
    private EurekaDeployment eurekaDeployment;

    private EurekaRegistrationClient registrationClient;
    private EurekaInterestClient interestClient;
    private InstanceInfo registeringInfo;

    @Before
    public void setup() {
        eurekaDeployment = eurekaDeploymentResource.getEurekaDeployment();
        registrationClient = eurekaDeploymentResource.registrationClientToWriteCluster();
        interestClient = eurekaDeploymentResource.cannonicalInterestClient();
        registeringInfo = SampleInstanceInfo.CliServer.build();
    }

    @After
    public void tearDown() {
        registrationClient.shutdown();
        interestClient.shutdown();
    }

    @Test(timeout = 30000)
    public void testReadServerFetchesDataFromWriteServerRegistry() throws Exception {
        // Listen to interest stream updates
        ExtTestSubscriber<ChangeNotification<InstanceInfo>> notificationSubscriber = new ExtTestSubscriber<>();
        interestClient.forInterest(Interests.forApplications(registeringInfo.getApp()))
                .filter(dataOnlyFilter())
                .subscribe(notificationSubscriber);

        // Register
        Subscription subscription = registrationClient.register(Observable.just(registeringInfo)).subscribe();
        assertThat(notificationSubscriber.takeNextOrWait(), is(addChangeNotificationOf(registeringInfo)));

        // Unregister
        subscription.unsubscribe();
        assertThat(notificationSubscriber.takeNextOrWait(), is(deleteChangeNotificationOf(registeringInfo)));
    }

    @Test(timeout = 30000)
    public void testReadServerFailoversToAnotherWriteServerIfFirstOneCrashes() throws Exception {
        // Listen to interest stream updates
        ExtTestSubscriber<ChangeNotification<InstanceInfo>> notificationSubscriber = new ExtTestSubscriber<>();
        interestClient.forInterest(Interests.forApplications(registeringInfo.getApp()))
                .filter(dataOnlyFilter())
                .subscribe(notificationSubscriber);

        // Scale write cluster up so we have a node to failover
        eurekaDeployment.getWriteCluster().scaleUpByOne();

        // Disconnect network connection to the first write node
        NetworkLink networkLink = eurekaDeployment.getNetworkRouter()
                .getLinkTo(eurekaDeployment.getWriteCluster().getServer(0).getDiscoveryPort());
        networkLink.disconnect();

        // Register
        registrationClient.register(Observable.just(registeringInfo)).subscribe();
        assertThat(notificationSubscriber.takeNextOrWait(), is(addChangeNotificationOf(registeringInfo)));
    }
}


File: eureka2-integration/src/test/java/com/netflix/eureka2/integration/server/replication/EvictionInReplicationChannelTest.java
package com.netflix.eureka2.integration.server.replication;

import com.netflix.eureka2.integration.EurekaDeploymentClients;
import com.netflix.eureka2.junit.categories.ExperimentalTest;
import com.netflix.eureka2.junit.categories.IntegrationTest;
import com.netflix.eureka2.registry.instance.InstanceInfo;
import com.netflix.eureka2.testkit.data.builder.SampleInstanceInfo;
import com.netflix.eureka2.testkit.embedded.EurekaDeployment;
import com.netflix.eureka2.testkit.junit.resources.EurekaDeploymentResource;
import com.netflix.eureka2.testkit.netrouter.NetworkLink;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.experimental.categories.Category;

import static com.netflix.eureka2.testkit.junit.resources.EurekaDeploymentResource.anEurekaDeploymentResource;

/**
 * @author Tomasz Bak
 */
@Category({IntegrationTest.class, ExperimentalTest.class})
public class EvictionInReplicationChannelTest {

    private static final int CLUSTER_SIZE = 20;

    @Rule
    public final EurekaDeploymentResource eurekaDeploymentResource =
            anEurekaDeploymentResource(2, 0).withNetworkRouter(true).build();

    private EurekaDeployment eurekaDeployment;

    private EurekaDeploymentClients eurekaDeploymentClients;

    @Before
    public void setUp() throws Exception {
        eurekaDeployment = eurekaDeploymentResource.getEurekaDeployment();
        eurekaDeploymentClients = new EurekaDeploymentClients(eurekaDeployment);
    }

    /**
     * Disconnecting a replication channel and connecting it again should leave the system in
     * clean state with no stale registrations.
     */
    @Test
    public void testRegistryEvictionOnReplicationChannelReconnect() throws Exception {
        // Fill registry content of write server 1 and verify that server 0 has it
        InstanceInfo firstTemplate = SampleInstanceInfo.WebServer.build();
        eurekaDeploymentClients.fillUpRegistryOfServer(1, CLUSTER_SIZE, firstTemplate);
        eurekaDeploymentClients.verifyWriteServerRegistryContent(0, firstTemplate.getApp(), CLUSTER_SIZE);

        // Now simulate network failure
        NetworkLink replicationLink = eurekaDeployment.getNetworkRouter()
                .getLinkTo(eurekaDeployment.getWriteCluster().getServer(0).getReplicationPort());
        replicationLink.disconnect();

        InstanceInfo secondTemplate = SampleInstanceInfo.Backend.build();
        eurekaDeploymentClients.fillUpRegistryOfServer(1, CLUSTER_SIZE, secondTemplate);

        eurekaDeploymentClients.verifyWriteServerRegistryContent(0, firstTemplate.getApp(), CLUSTER_SIZE);
        eurekaDeploymentClients.verifyWriteServerHasNoInstance(0, secondTemplate.getApp());

        // Restore replication channel
        replicationLink.connect();

        eurekaDeploymentClients.verifyWriteServerRegistryContent(0, secondTemplate.getApp(), CLUSTER_SIZE);
        eurekaDeploymentClients.verifyWriteServerHasNoInstance(0, firstTemplate.getApp());
    }
}


File: eureka2-test-utils/src/main/java/com/netflix/eureka2/junit/categories/ExperimentalTest.java
package com.netflix.eureka2.junit.categories;

/**
 * Test marker for tests that are still work in progress or cover functionality
 * that is yet not fully implemented.
 *
 * @author Tomasz Bak
 */
public interface ExperimentalTest {
}


File: eureka2-testkit/src/main/java/com/netflix/eureka2/testkit/embedded/EurekaDeployment.java
package com.netflix.eureka2.testkit.embedded;

import java.util.ArrayList;
import java.util.List;

import com.netflix.eureka2.client.EurekaInterestClient;
import com.netflix.eureka2.client.EurekaRegistrationClient;
import com.netflix.eureka2.client.Eurekas;
import com.netflix.eureka2.client.resolver.ServerResolver;
import com.netflix.eureka2.client.resolver.ServerResolvers;
import com.netflix.eureka2.config.BasicEurekaTransportConfig;
import com.netflix.eureka2.config.EurekaTransportConfig;
import com.netflix.eureka2.server.resolver.ClusterAddress.ServiceType;
import com.netflix.eureka2.testkit.embedded.cluster.EmbeddedReadCluster;
import com.netflix.eureka2.testkit.embedded.cluster.EmbeddedWriteCluster;
import com.netflix.eureka2.testkit.embedded.server.EmbeddedBridgeServer;
import com.netflix.eureka2.testkit.embedded.server.EmbeddedDashboardServer;
import com.netflix.eureka2.testkit.embedded.server.EmbeddedReadServer;
import com.netflix.eureka2.testkit.embedded.server.EmbeddedWriteServer;
import com.netflix.eureka2.testkit.embedded.view.ClusterViewHttpServer;
import com.netflix.eureka2.testkit.netrouter.NetworkRouter;
import com.netflix.eureka2.testkit.netrouter.NetworkRouters;

import static com.netflix.eureka2.interests.Interests.forVips;

/**
 * @author Tomasz Bak
 */
public class EurekaDeployment {

    private final EurekaTransportConfig transportConfig;
    private final EmbeddedWriteCluster writeCluster;
    private final EmbeddedReadCluster readCluster;
    private final EmbeddedBridgeServer bridgeServer;
    private final EmbeddedDashboardServer dashboardServer;
    private final NetworkRouter networkRouter;

    private final ClusterViewHttpServer deploymentView;

    private final List<EurekaInterestClient> connectedInterestClients = new ArrayList<>();
    private final List<EurekaRegistrationClient> connectedRegistrationClients = new ArrayList<>();

    protected EurekaDeployment(EurekaTransportConfig transportConfig,
                               EmbeddedWriteCluster writeCluster,
                               EmbeddedReadCluster readCluster,
                               EmbeddedBridgeServer bridgeServer,
                               EmbeddedDashboardServer dashboardServer,
                               NetworkRouter networkRouter,
                               boolean viewEnabled) {
        this.transportConfig = transportConfig;
        this.writeCluster = writeCluster;
        this.readCluster = readCluster;
        this.bridgeServer = bridgeServer;
        this.dashboardServer = dashboardServer;
        this.networkRouter = networkRouter;

        if (viewEnabled) {
            deploymentView = new ClusterViewHttpServer(this);
            deploymentView.start();
        } else {
            deploymentView = null;
        }
    }

    public EmbeddedWriteCluster getWriteCluster() {
        return writeCluster;
    }

    public EmbeddedReadCluster getReadCluster() {
        return readCluster;
    }

    public EmbeddedBridgeServer getBridgeServer() {
        return bridgeServer;
    }

    public EmbeddedDashboardServer getDashboardServer() {
        return dashboardServer;
    }

    public NetworkRouter getNetworkRouter() {
        return networkRouter;
    }

    /**
     * Create a {@link EurekaRegistrationClient} instance to register with a particular write server
     *
     * @param idx id of a write server where to connect
     */
    public EurekaRegistrationClient registrationClientToWriteServer(int idx) {
        EmbeddedWriteServer server = getWriteCluster().getServer(idx);
        EurekaRegistrationClient registrationClient = Eurekas.newRegistrationClientBuilder()
                .withTransportConfig(transportConfig)
                .withServerResolver(server.getRegistrationResolver())
                .build();
        connectedRegistrationClients.add(registrationClient);
        return registrationClient;
    }

    /**
     * Create a {@link EurekaRegistrationClient} instance to register with any instance in a write cluster
     */
    public EurekaRegistrationClient registrationClientToWriteCluster() {
        EurekaRegistrationClient registrationClient = Eurekas.newRegistrationClientBuilder()
                .withTransportConfig(transportConfig)
                .withServerResolver(getWriteCluster().registrationResolver())
                .build();
        connectedRegistrationClients.add(registrationClient);
        return registrationClient;
    }

    /**
     * Create a {@link EurekaInterestClient} instance to do interest discovery with a particular write server
     *
     * @param idx id of a write server where to connect
     */
    public EurekaInterestClient interestClientToWriteServer(int idx) {
        EmbeddedWriteServer server = getWriteCluster().getServer(idx);
        EurekaInterestClient interestClient = Eurekas.newInterestClientBuilder()
                .withTransportConfig(transportConfig)
                .withServerResolver(server.getInterestResolver())
                .build();
        connectedInterestClients.add(interestClient);
        return interestClient;
    }

    /**
     * Create a {@link EurekaInterestClient} instance to do interest discovery with any instance in a write cluster
     */
    public EurekaInterestClient interestClientToWriteCluster() {
        EurekaInterestClient interestClient = Eurekas.newInterestClientBuilder()
                .withTransportConfig(transportConfig)
                .withServerResolver(getWriteCluster().interestResolver())
                .build();
        connectedInterestClients.add(interestClient);
        return interestClient;
    }

    /**
     * Create a {@link EurekaInterestClient} instance to do interest discovery with a particular read server
     *
     * @param idx id of a write server where to connect
     */
    public EurekaInterestClient interestClientToReadServer(int idx) {
        EmbeddedReadServer server = getReadCluster().getServer(idx);
        EurekaInterestClient interestClient = Eurekas.newInterestClientBuilder()
                .withTransportConfig(transportConfig)
                .withServerResolver(server.getInterestResolver())
                .build();
        connectedInterestClients.add(interestClient);
        return interestClient;
    }

    /**
     * Create a {@link EurekaInterestClient} instance to do interest discovery with any instance in a read cluster
     */
    public EurekaInterestClient interestClientToReadCluster() {
        EurekaInterestClient interestClient = Eurekas.newInterestClientBuilder()
                .withTransportConfig(transportConfig)
                .withServerResolver(getReadCluster().interestResolver())
                .build();
        connectedInterestClients.add(interestClient);
        return interestClient;
    }

    /**
     * Create a {@link EurekaInterestClient} instance to do interest discovery with any instance in a read cluster,
     * using the canonical method to first discover the read cluster from the write cluster
     */
    public EurekaInterestClient cannonicalInterestClient() {
        EurekaInterestClient interestClient = Eurekas.newInterestClientBuilder()
                .withTransportConfig(transportConfig)
                .withServerResolver(ServerResolvers.fromEureka(getWriteCluster().interestResolver())
                        .forInterest(forVips(getReadCluster().getVip())))
                .build();
        connectedInterestClients.add(interestClient);
        return interestClient;
    }

    public void shutdown() {
        for (EurekaInterestClient interestClient : connectedInterestClients) {
            interestClient.shutdown();
        }
        connectedInterestClients.clear();
        for (EurekaRegistrationClient registrationClient : connectedRegistrationClients) {
            registrationClient.shutdown();
        }
        connectedRegistrationClients.clear();

        writeCluster.shutdown();
        readCluster.shutdown();
        if (bridgeServer != null) {
            bridgeServer.shutdown();
        }
        if (dashboardServer != null) {
            dashboardServer.shutdown();
        }
        if (deploymentView != null) {
            deploymentView.shutdown();
        }
    }

    public static class EurekaDeploymentBuilder {

        private EurekaTransportConfig transportConfig;
        private int writeClusterSize;
        private int readClusterSize;
        private boolean ephemeralPorts;
        private boolean networkRouterEnabled;
        private boolean bridgeEnabled;
        private boolean dashboardEnabled;
        private boolean adminUIEnabled;
        private boolean extensionsEnabled;
        private boolean viewEnabled;

        public EurekaDeploymentBuilder withWriteClusterSize(int size) {
            writeClusterSize = size;
            return this;
        }

        public EurekaDeploymentBuilder withReadClusterSize(int size) {
            readClusterSize = size;
            return this;
        }

        public EurekaDeploymentBuilder withEphemeralPorts(boolean ephemeralPorts) {
            this.ephemeralPorts = ephemeralPorts;
            return this;
        }

        public EurekaDeploymentBuilder withNetworkRouter(boolean networkRouterEnabled) {
            this.networkRouterEnabled = networkRouterEnabled;
            return this;
        }

        public EurekaDeploymentBuilder withTransportConfig(EurekaTransportConfig transportConfig) {
            this.transportConfig = transportConfig;
            return this;
        }

        public EurekaDeploymentBuilder withBridge(boolean bridgeEnabled) {
            this.bridgeEnabled = bridgeEnabled;
            return this;
        }

        public EurekaDeploymentBuilder withDashboard(boolean dashboardEnabled) {
            this.dashboardEnabled = dashboardEnabled;
            return this;
        }

        public EurekaDeploymentBuilder withAdminUI(boolean adminUIEnabled) {
            this.adminUIEnabled = adminUIEnabled;
            return this;
        }

        public EurekaDeploymentBuilder withExtensions(boolean extensionsEnabled) {
            this.extensionsEnabled = extensionsEnabled;
            return this;
        }

        public EurekaDeploymentBuilder withDeploymentView(boolean viewEnabled) {
            this.viewEnabled = viewEnabled;
            return this;
        }

        public EurekaDeployment build() {
            if (transportConfig == null) {
                transportConfig = new BasicEurekaTransportConfig.Builder().build();
            }
            NetworkRouter networkRouter = networkRouterEnabled ? NetworkRouters.aRouter() : null;
            EmbeddedWriteCluster writeCluster = new EmbeddedWriteCluster(extensionsEnabled, adminUIEnabled, ephemeralPorts, transportConfig.getCodec(), networkRouter);
            writeCluster.scaleUpBy(writeClusterSize);

            EmbeddedReadCluster readCluster = new EmbeddedReadCluster(writeCluster.registrationResolver(),
                    writeCluster.interestResolver(), extensionsEnabled, adminUIEnabled, ephemeralPorts, transportConfig.getCodec(), networkRouter);
            readCluster.scaleUpBy(readClusterSize);

            EmbeddedBridgeServer bridgeServer = null;
            if (bridgeEnabled) {
                bridgeServer = EmbeddedBridgeServer.newBridge(writeCluster.resolvePeers(ServiceType.Replication), extensionsEnabled, adminUIEnabled, transportConfig.getCodec());
                bridgeServer.start();
            }
            EmbeddedDashboardServer dashboardServer = null;
            if (dashboardEnabled) {
                int discoveryPort;
                ServerResolver readClusterResolver;
                if (readClusterSize > 0) {
                    discoveryPort = readCluster.getServer(0).getDiscoveryPort();
                    readClusterResolver = ServerResolvers.fromEureka(writeCluster.interestResolver()).forInterest(forVips(readCluster.getVip()));
                } else {
                    discoveryPort = writeCluster.getServer(0).getDiscoveryPort();
                    readClusterResolver = writeCluster.interestResolver();
                }

                dashboardServer = EmbeddedDashboardServer.newDashboard(
                        writeCluster.registrationResolver(),
                        readClusterResolver,
                        discoveryPort,
                        extensionsEnabled,
                        adminUIEnabled,
                        ephemeralPorts,
                        transportConfig.getCodec()
                );
                dashboardServer.start();
            }
            return new EurekaDeployment(transportConfig, writeCluster, readCluster, bridgeServer, dashboardServer, networkRouter, viewEnabled);
        }
    }
}


File: eureka2-testkit/src/main/java/com/netflix/eureka2/testkit/embedded/cluster/EmbeddedReadCluster.java
package com.netflix.eureka2.testkit.embedded.cluster;

import java.util.ArrayList;
import java.util.List;

import com.netflix.eureka2.Server;
import com.netflix.eureka2.client.resolver.ServerResolver;
import com.netflix.eureka2.client.resolver.ServerResolvers;
import com.netflix.eureka2.codec.CodecType;
import com.netflix.eureka2.registry.datacenter.LocalDataCenterInfo.DataCenterType;
import com.netflix.eureka2.server.config.EurekaServerConfig;
import com.netflix.eureka2.testkit.embedded.cluster.EmbeddedReadCluster.ReadClusterReport;
import com.netflix.eureka2.testkit.embedded.server.EmbeddedReadServer;
import com.netflix.eureka2.testkit.embedded.server.EmbeddedReadServer.ReadServerReport;
import com.netflix.eureka2.testkit.netrouter.NetworkRouter;

/**
 * @author Tomasz Bak
 */
public class EmbeddedReadCluster extends EmbeddedEurekaCluster<EmbeddedReadServer, Server, ReadClusterReport> {

    public static final String READ_SERVER_NAME = "eureka2-read";
    public static final int READ_SERVER_PORTS_FROM = 14000;

    private final ServerResolver registrationResolver;
    private final ServerResolver discoveryResolver;
    private final boolean withExt;
    private final boolean withAdminUI;
    private final boolean ephemeralPorts;
    private final CodecType codec;
    private final NetworkRouter networkRouter;

    private int nextAvailablePort = READ_SERVER_PORTS_FROM;

    public EmbeddedReadCluster(ServerResolver registrationResolver,
                               ServerResolver discoveryResolver,
                               boolean withExt,
                               boolean withAdminUI,
                               boolean ephemeralPorts,
                               NetworkRouter networkRouter) {
        this(registrationResolver, discoveryResolver, withExt, withAdminUI, ephemeralPorts, CodecType.Avro, networkRouter);
    }

    public EmbeddedReadCluster(ServerResolver registrationResolver,
                               ServerResolver discoveryResolver,
                               boolean withExt,
                               boolean withAdminUI,
                               boolean ephemeralPorts,
                               CodecType codec,
                               NetworkRouter networkRouter) {
        super(READ_SERVER_NAME);
        this.registrationResolver = registrationResolver;
        this.discoveryResolver = discoveryResolver;
        this.withExt = withExt;
        this.withAdminUI = withAdminUI;
        this.ephemeralPorts = ephemeralPorts;
        this.codec = codec;
        this.networkRouter = networkRouter;
    }

    @Override
    public int scaleUpByOne() {
        int discoveryPort = ephemeralPorts ? 0 : nextAvailablePort;
        int httpPort = ephemeralPorts ? 0 : nextAvailablePort + 1;
        int adminPort = ephemeralPorts ? 0 : nextAvailablePort + 2;

        EurekaServerConfig config = EurekaServerConfig.baseBuilder()
                .withAppName(READ_SERVER_NAME)
                .withVipAddress(READ_SERVER_NAME)
                .withReadClusterVipAddress(READ_SERVER_NAME)
                .withDataCenterType(DataCenterType.Basic)
                .withDiscoveryPort(discoveryPort)
                .withHttpPort(httpPort)
                .withShutDownPort(0) // We do not run shutdown service in embedded server
                .withWebAdminPort(adminPort)
                .withCodec(codec)
                .build();

        EmbeddedReadServer newServer = newServer(config);
        newServer.start();

        nextAvailablePort += 10;

        if (ephemeralPorts) {
            discoveryPort = newServer.getDiscoveryPort();
        }

        return scaleUpByOne(newServer, new Server("localhost", discoveryPort));
    }

    protected EmbeddedReadServer newServer(EurekaServerConfig config) {
        return new EmbeddedReadServer(
                nextAvailableServerId(),
                config,
                registrationResolver,
                discoveryResolver,
                networkRouter,
                withExt,
                withAdminUI
        );
    }

    @Override
    public ReadClusterReport clusterReport() {
        List<ReadServerReport> serverReports = new ArrayList<>();
        for (EmbeddedReadServer server : servers) {
            serverReports.add(server.serverReport());
        }
        return new ReadClusterReport(serverReports);
    }

    public ServerResolver interestResolver() {
        return ServerResolvers.fromServerSource(clusterChangeObservable());
    }

    public static class ReadClusterReport {

        private final List<ReadServerReport> serverReports;

        public ReadClusterReport(List<ReadServerReport> serverReports) {
            this.serverReports = serverReports;
        }

        public List<ReadServerReport> getServerReports() {
            return serverReports;
        }
    }
}


File: eureka2-testkit/src/main/java/com/netflix/eureka2/testkit/embedded/cluster/EmbeddedWriteCluster.java
package com.netflix.eureka2.testkit.embedded.cluster;

import java.util.ArrayList;
import java.util.List;

import com.netflix.eureka2.Server;
import com.netflix.eureka2.client.resolver.ServerResolver;
import com.netflix.eureka2.client.resolver.ServerResolvers;
import com.netflix.eureka2.codec.CodecType;
import com.netflix.eureka2.interests.ChangeNotification;
import com.netflix.eureka2.interests.ChangeNotification.Kind;
import com.netflix.eureka2.registry.datacenter.LocalDataCenterInfo.DataCenterType;
import com.netflix.eureka2.server.config.WriteServerConfig;
import com.netflix.eureka2.server.resolver.ClusterAddress;
import com.netflix.eureka2.server.resolver.ClusterAddress.ServiceType;
import com.netflix.eureka2.testkit.embedded.cluster.EmbeddedWriteCluster.WriteClusterReport;
import com.netflix.eureka2.testkit.embedded.server.EmbeddedWriteServer;
import com.netflix.eureka2.testkit.embedded.server.EmbeddedWriteServer.WriteServerReport;
import com.netflix.eureka2.testkit.netrouter.NetworkRouter;
import com.netflix.eureka2.utils.rx.RxFunctions;
import rx.Observable;
import rx.functions.Func1;

/**
 * @author Tomasz Bak
 */
public class EmbeddedWriteCluster extends EmbeddedEurekaCluster<EmbeddedWriteServer, ClusterAddress, WriteClusterReport> {

    public static final String WRITE_SERVER_NAME = "eureka2-write";
    public static final int WRITE_SERVER_PORTS_FROM = 13000;

    private final boolean withExt;
    private final boolean withAdminUI;
    private final boolean ephemeralPorts;
    private final CodecType codec;
    private final NetworkRouter networkRouter;

    private int nextAvailablePort = WRITE_SERVER_PORTS_FROM;

    public EmbeddedWriteCluster(boolean withExt, boolean withAdminUI, boolean ephemeralPorts, NetworkRouter networkRouter) {
        this(withExt, withAdminUI, ephemeralPorts, CodecType.Avro, networkRouter);
    }

    public EmbeddedWriteCluster(boolean withExt, boolean withAdminUI, boolean ephemeralPorts, CodecType codec, NetworkRouter networkRouter) {
        super(WRITE_SERVER_NAME);
        this.withExt = withExt;
        this.withAdminUI = withAdminUI;
        this.ephemeralPorts = ephemeralPorts;
        this.codec = codec;
        this.networkRouter = networkRouter;
    }

    @Override
    public int scaleUpByOne() {
        ClusterAddress writeServerAddress = ephemeralPorts ?
                ClusterAddress.writeClusterAddressFrom("localhost", 0, 0, 0) :
                ClusterAddress.writeClusterAddressFrom("localhost", nextAvailablePort, nextAvailablePort + 1, nextAvailablePort + 2);

        int httpPort = ephemeralPorts ? 0 : nextAvailablePort + 3;
        int adminPort = ephemeralPorts ? 0 : nextAvailablePort + 4;

        WriteServerConfig config = WriteServerConfig.writeBuilder()
                .withAppName(WRITE_SERVER_NAME)
                .withVipAddress(WRITE_SERVER_NAME)
                .withReadClusterVipAddress(EmbeddedReadCluster.READ_SERVER_NAME)
                .withDataCenterType(DataCenterType.Basic)
                .withRegistrationPort(writeServerAddress.getRegistrationPort())
                .withDiscoveryPort(writeServerAddress.getInterestPort())
                .withReplicationPort(writeServerAddress.getReplicationPort())
                .withServerList(new String[]{writeServerAddress.toWriteAddressString()})
                .withCodec(codec)
                .withHttpPort(httpPort)
                .withShutDownPort(0) // We do not run shutdown service in embedded server
                .withWebAdminPort(adminPort)
                .withReplicationRetryMillis(1000)
                .build();
        EmbeddedWriteServer newServer = newServer(config);
        newServer.start();

        nextAvailablePort += 10;

        if (ephemeralPorts) {
            writeServerAddress = ClusterAddress.writeClusterAddressFrom("localhost", newServer.getRegistrationPort(),
                    newServer.getDiscoveryPort(), newServer.getReplicationPort());
        }

        return scaleUpByOne(newServer, writeServerAddress);
    }

    protected EmbeddedWriteServer newServer(WriteServerConfig config) {
        return new EmbeddedWriteServer(
                config,
                resolvePeers(ServiceType.Interest),
                resolvePeers(ServiceType.Replication),
                networkRouter,
                withExt,
                withAdminUI
        );
    }

    @Override
    public void scaleDownByOne(int idx) {
        super.scaleDownByOne(idx);
    }

    @Override
    public WriteClusterReport clusterReport() {
        List<WriteServerReport> serverReports = new ArrayList<>();
        for (EmbeddedWriteServer server : servers) {
            serverReports.add(server.serverReport());
        }
        return new WriteClusterReport(serverReports);
    }

    public ServerResolver registrationResolver() {
        return getServerResolver(new Func1<ClusterAddress, Integer>() {
            @Override
            public Integer call(ClusterAddress writeServerAddress) {
                return writeServerAddress.getRegistrationPort();
            }
        });
    }

    public ServerResolver interestResolver() {
        return getServerResolver(new Func1<ClusterAddress, Integer>() {
            @Override
            public Integer call(ClusterAddress writeServerAddress) {
                return writeServerAddress.getInterestPort();
            }
        });
    }

    public Observable<ChangeNotification<Server>> resolvePeers(final ServiceType serviceType) {
        return clusterChangeObservable().map(
                new Func1<ChangeNotification<ClusterAddress>, ChangeNotification<Server>>() {
                    @Override
                    public ChangeNotification<Server> call(ChangeNotification<ClusterAddress> notification) {
                        if (notification.getKind() == Kind.BufferSentinel) {
                            return null;
                        }

                        ClusterAddress data = notification.getData();
                        int port;
                        switch (serviceType) {
                            case Registration:
                                port = data.getRegistrationPort();
                                break;
                            case Interest:
                                port = data.getInterestPort();
                                break;
                            case Replication:
                                port = data.getReplicationPort();
                                break;
                            default:
                                throw new IllegalStateException("Unexpected enum value " + serviceType);
                        }
                        Server serverAddress = new Server(data.getHostName(), port);
                        switch (notification.getKind()) {
                            case Add:
                                return new ChangeNotification<Server>(Kind.Add, serverAddress);
                            case Modify:
                                throw new IllegalStateException("Modify not expected");
                            case Delete:
                                return new ChangeNotification<Server>(Kind.Delete, serverAddress);
                        }
                        return null;
                    }
                }).filter(RxFunctions.filterNullValuesFunc());
    }

    private ServerResolver getServerResolver(final Func1<ClusterAddress, Integer> portFunc) {
        Observable<ChangeNotification<Server>> serverSource = clusterChangeObservable().map(new Func1<ChangeNotification<ClusterAddress>, ChangeNotification<Server>>() {
            @Override
            public ChangeNotification<Server> call(ChangeNotification<ClusterAddress> notification) {
                if (notification.getKind() == Kind.BufferSentinel) {
                    return ChangeNotification.bufferSentinel();
                }

                ClusterAddress endpoints = notification.getData();
                int port = portFunc.call(endpoints);
                switch (notification.getKind()) {
                    case Add:
                        return new ChangeNotification<>(Kind.Add, new Server(endpoints.getHostName(), port));
                    case Modify:
                        throw new IllegalStateException("Modify not expected");
                    case Delete:
                        return new ChangeNotification<>(Kind.Delete, new Server(endpoints.getHostName(), port));
                    default:
                        //no-op
                }
                return null;
            }
        }).filter(RxFunctions.filterNullValuesFunc());

        return ServerResolvers.fromServerSource(serverSource);
    }

    public static class WriteClusterReport {
        private final List<WriteServerReport> serverReports;

        public WriteClusterReport(List<WriteServerReport> serverReports) {
            this.serverReports = serverReports;
        }

        public List<WriteServerReport> getServerReports() {
            return serverReports;
        }
    }
}


File: eureka2-testkit/src/main/java/com/netflix/eureka2/testkit/embedded/server/EmbeddedReadServer.java
package com.netflix.eureka2.testkit.embedded.server;

import java.util.Properties;

import com.google.inject.AbstractModule;
import com.google.inject.Module;
import com.netflix.eureka2.channel.InterestChannel;
import com.netflix.eureka2.client.EurekaInterestClient;
import com.netflix.eureka2.client.EurekaRegistrationClient;
import com.netflix.eureka2.client.Eurekas;
import com.netflix.eureka2.client.channel.ClientChannelFactory;
import com.netflix.eureka2.client.channel.InterestChannelFactory;
import com.netflix.eureka2.client.interest.BatchAwareIndexRegistry;
import com.netflix.eureka2.client.interest.BatchingRegistry;
import com.netflix.eureka2.client.resolver.ServerResolver;
import com.netflix.eureka2.client.resolver.ServerResolvers;
import com.netflix.eureka2.config.BasicEurekaRegistryConfig;
import com.netflix.eureka2.config.BasicEurekaRegistryConfig.Builder;
import com.netflix.eureka2.config.BasicEurekaTransportConfig;
import com.netflix.eureka2.eureka1.rest.Eureka1Configuration;
import com.netflix.eureka2.eureka1.rest.Eureka1RestApiModule;
import com.netflix.eureka2.interests.IndexRegistryImpl;
import com.netflix.eureka2.registry.PreservableEurekaRegistry;
import com.netflix.eureka2.registry.SourcedEurekaRegistryImpl;
import com.netflix.eureka2.registry.instance.InstanceInfo;
import com.netflix.eureka2.server.EurekaReadServerModule;
import com.netflix.eureka2.server.config.EurekaServerConfig;
import com.netflix.eureka2.server.interest.FullFetchBatchingRegistry;
import com.netflix.eureka2.server.interest.FullFetchInterestClient;
import com.netflix.eureka2.server.spi.ExtAbstractModule.ServerType;
import com.netflix.eureka2.server.transport.tcp.discovery.TcpDiscoveryServer;
import com.netflix.eureka2.testkit.embedded.server.EmbeddedReadServer.ReadServerReport;
import com.netflix.eureka2.testkit.netrouter.NetworkRouter;

import static com.netflix.eureka2.metric.EurekaRegistryMetricFactory.registryMetrics;
import static com.netflix.eureka2.metric.client.EurekaClientMetricFactory.clientMetrics;

/**
 * @author Tomasz Bak
 */
public class EmbeddedReadServer extends EmbeddedEurekaServer<EurekaServerConfig, ReadServerReport> {
    private final String serverId;
    private final ServerResolver registrationResolver;
    private final ServerResolver discoveryResolver;
    private final NetworkRouter networkRouter;

    public EmbeddedReadServer(String serverId,
                              EurekaServerConfig config,
                              ServerResolver registrationResolver,
                              ServerResolver discoveryResolver,
                              NetworkRouter networkRouter,
                              boolean withExt,
                              boolean withDashboard) {
        super(ServerType.Read, config, withExt, withDashboard);
        this.serverId = serverId;
        this.registrationResolver = registrationResolver;
        this.discoveryResolver = discoveryResolver;
        this.networkRouter = networkRouter;
    }

    @Override
    public void start() {
        EurekaRegistrationClient registrationClient = Eurekas.newRegistrationClientBuilder()
                .withServerResolver(registrationResolver)
                .build();

        // TODO We need to better encapsulate EurekaInterestClient construction
        BatchingRegistry<InstanceInfo> remoteBatchingRegistry = new FullFetchBatchingRegistry<>();
        BatchAwareIndexRegistry<InstanceInfo> indexRegistry = new BatchAwareIndexRegistry<>(
                new IndexRegistryImpl<InstanceInfo>(), remoteBatchingRegistry);

        BasicEurekaRegistryConfig registryConfig = new Builder().build();
        BasicEurekaTransportConfig transportConfig = new BasicEurekaTransportConfig.Builder().build();

        PreservableEurekaRegistry registry = new PreservableEurekaRegistry(
                new SourcedEurekaRegistryImpl(indexRegistry, registryMetrics()),
                registryConfig,
                registryMetrics()
        );

        ClientChannelFactory<InterestChannel> channelFactory = new InterestChannelFactory(
                serverId,
                transportConfig,
                discoveryResolver,
                registry,
                remoteBatchingRegistry,
                clientMetrics()
        );

        EurekaInterestClient interestClient = new FullFetchInterestClient(registry, channelFactory);

        Module[] modules = {
                new EurekaReadServerModule(config, registrationClient, interestClient),
                new AbstractModule() {
                    @Override
                    protected void configure() {
                        if (networkRouter != null) {
                            bind(NetworkRouter.class).toInstance(networkRouter);
                            bind(TcpDiscoveryServer.class).to(EmbeddedTcpDiscoveryServer.class);
                        }
                    }
                },
                new Eureka1RestApiModule(new Eureka1Configuration(), registrationClient)
        };

        setup(modules);
    }

    @Override
    protected void loadInstanceProperties(Properties props) {
        super.loadInstanceProperties(props);
        props.setProperty("eureka.client.discovery-endpoint.port", Integer.toString(config.getDiscoveryPort()));
    }

    public int getDiscoveryPort() {
        // Since server might be started on the ephemeral port, we need to get it directly from RxNetty server
        return injector.getInstance(TcpDiscoveryServer.class).serverPort();
    }

    @Override
    public ServerResolver getInterestResolver() {
        return ServerResolvers.fromHostname("localhost").withPort(getDiscoveryPort());
    }

    @Override
    public ReadServerReport serverReport() {
        return new ReadServerReport(getDiscoveryPort(), getHttpServerPort(), getWebAdminPort());
    }

    public static class ReadServerReport extends AbstractServerReport {
        private final int discoveryPort;

        public ReadServerReport(int discoveryPort, int httpServerPort, int adminPort) {
            super(httpServerPort, adminPort);
            this.discoveryPort = discoveryPort;
        }

        public int getDiscoveryPort() {
            return discoveryPort;
        }
    }
}


File: eureka2-testkit/src/main/java/com/netflix/eureka2/testkit/embedded/server/EmbeddedTcpDiscoveryServer.java
package com.netflix.eureka2.testkit.embedded.server;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import javax.inject.Inject;
import javax.inject.Named;
import javax.inject.Provider;
import javax.inject.Singleton;

import com.netflix.eureka2.server.config.EurekaServerConfig;
import com.netflix.eureka2.server.transport.tcp.discovery.TcpDiscoveryHandler;
import com.netflix.eureka2.server.transport.tcp.discovery.TcpDiscoveryServer;
import com.netflix.eureka2.testkit.netrouter.NetworkRouter;
import io.reactivex.netty.metrics.MetricEventsListenerFactory;

/**
 * @author Tomasz Bak
 */
@Singleton
public class EmbeddedTcpDiscoveryServer extends TcpDiscoveryServer {

    private final NetworkRouter networkRouter;
    private int proxyPort;

    @Inject
    public EmbeddedTcpDiscoveryServer(EurekaServerConfig config,
                                      @Named("discovery") MetricEventsListenerFactory servoEventsListenerFactory,
                                      Provider<TcpDiscoveryHandler> tcpDiscoveryHandler,
                                      NetworkRouter networkRouter) {
        super(config, servoEventsListenerFactory, tcpDiscoveryHandler);
        this.networkRouter = networkRouter;
    }

    @PostConstruct
    @Override
    public void start() {
        super.start();
        proxyPort = networkRouter.bridgeTo(super.serverPort());
    }

    @PreDestroy
    @Override
    public void stop() {
        networkRouter.removeBridgeTo(super.serverPort());
        super.stop();
    }

    @Override
    public int serverPort() {
        return proxyPort;
    }
}


File: eureka2-testkit/src/main/java/com/netflix/eureka2/testkit/embedded/server/EmbeddedTcpRegistrationServer.java
package com.netflix.eureka2.testkit.embedded.server;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import javax.inject.Inject;
import javax.inject.Named;
import javax.inject.Provider;
import javax.inject.Singleton;

import com.netflix.eureka2.server.config.WriteServerConfig;
import com.netflix.eureka2.server.transport.tcp.registration.TcpRegistrationHandler;
import com.netflix.eureka2.server.transport.tcp.registration.TcpRegistrationServer;
import com.netflix.eureka2.testkit.netrouter.NetworkRouter;
import io.reactivex.netty.metrics.MetricEventsListenerFactory;

/**
 * @author Tomasz Bak
 */
@Singleton
public class EmbeddedTcpRegistrationServer extends TcpRegistrationServer {

    private final NetworkRouter networkRouter;
    private int proxyPort;

    @Inject
    public EmbeddedTcpRegistrationServer(WriteServerConfig config,
                                         @Named("registration") MetricEventsListenerFactory servoEventsListenerFactory,
                                         Provider<TcpRegistrationHandler> tcpRegistrationHandler,
                                         NetworkRouter networkRouter) {
        super(config, servoEventsListenerFactory, tcpRegistrationHandler);
        this.networkRouter = networkRouter;
    }

    @PostConstruct
    @Override
    public void start() {
        super.start();
        proxyPort = networkRouter.bridgeTo(super.serverPort());
    }

    @PreDestroy
    @Override
    public void stop() {
        networkRouter.removeBridgeTo(super.serverPort());
        super.stop();
    }

    @Override
    public int serverPort() {
        return proxyPort;
    }
}


File: eureka2-testkit/src/main/java/com/netflix/eureka2/testkit/embedded/server/EmbeddedTcpReplicationServer.java
package com.netflix.eureka2.testkit.embedded.server;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import javax.inject.Inject;
import javax.inject.Named;
import javax.inject.Provider;
import javax.inject.Singleton;

import com.netflix.eureka2.server.config.WriteServerConfig;
import com.netflix.eureka2.server.transport.tcp.replication.TcpReplicationHandler;
import com.netflix.eureka2.server.transport.tcp.replication.TcpReplicationServer;
import com.netflix.eureka2.testkit.netrouter.NetworkRouter;
import io.reactivex.netty.metrics.MetricEventsListenerFactory;

/**
 * @author Tomasz Bak
 */
@Singleton
public class EmbeddedTcpReplicationServer extends TcpReplicationServer {
    private final NetworkRouter networkRouter;
    private int proxyPort;

    @Inject
    public EmbeddedTcpReplicationServer(WriteServerConfig config,
                                        Provider<TcpReplicationHandler> tcpReplicationHandler,
                                        @Named("replication") MetricEventsListenerFactory servoEventsListenerFactory,
                                        NetworkRouter networkRouter) {
        super(config, tcpReplicationHandler, servoEventsListenerFactory);
        this.networkRouter = networkRouter;
    }


    @PostConstruct
    @Override
    public void start() {
        super.start();
        proxyPort = networkRouter.bridgeTo(super.serverPort());
    }

    @PreDestroy
    @Override
    public void stop() {
        networkRouter.removeBridgeTo(super.serverPort());
        super.stop();
    }

    @Override
    public int serverPort() {
        return proxyPort;
    }

}


File: eureka2-testkit/src/main/java/com/netflix/eureka2/testkit/embedded/server/EmbeddedWriteServer.java
package com.netflix.eureka2.testkit.embedded.server;

import java.util.Properties;

import com.google.inject.AbstractModule;
import com.google.inject.Module;
import com.netflix.eureka2.Server;
import com.netflix.eureka2.client.resolver.ServerResolver;
import com.netflix.eureka2.client.resolver.ServerResolvers;
import com.netflix.eureka2.eureka1.rest.Eureka1Configuration;
import com.netflix.eureka2.eureka1.rest.Eureka1RestApiModule;
import com.netflix.eureka2.interests.ChangeNotification;
import com.netflix.eureka2.server.EurekaWriteServerModule;
import com.netflix.eureka2.server.InterestPeerAddressProvider;
import com.netflix.eureka2.server.ReplicationPeerAddressesProvider;
import com.netflix.eureka2.server.config.WriteServerConfig;
import com.netflix.eureka2.server.spi.ExtAbstractModule.ServerType;
import com.netflix.eureka2.server.transport.tcp.discovery.TcpDiscoveryServer;
import com.netflix.eureka2.server.transport.tcp.registration.TcpRegistrationServer;
import com.netflix.eureka2.server.transport.tcp.replication.TcpReplicationServer;
import com.netflix.eureka2.testkit.embedded.server.EmbeddedWriteServer.WriteServerReport;
import com.netflix.eureka2.testkit.netrouter.NetworkRouter;
import rx.Observable;

/**
 * @author Tomasz Bak
 */
public class EmbeddedWriteServer extends EmbeddedEurekaServer<WriteServerConfig, WriteServerReport> {

    private final Observable<ChangeNotification<Server>> interestPeers;
    private final Observable<ChangeNotification<Server>> replicationPeers;
    private final NetworkRouter networkRouter;

    public EmbeddedWriteServer(final WriteServerConfig config,
                               final Observable<ChangeNotification<Server>> interestPeers,
                               final Observable<ChangeNotification<Server>> replicationPeers,
                               NetworkRouter networkRouter,
                               boolean withExt,
                               boolean withDashboards) {
        super(ServerType.Write, config, withExt, withDashboards);
        this.interestPeers = interestPeers;
        this.replicationPeers = replicationPeers;
        this.networkRouter = networkRouter;
    }

    @Override
    public void start() {
        Module[] modules = {
                new EurekaWriteServerModule(config),
                new AbstractModule() {
                    @Override
                    protected void configure() {
                        bind(InterestPeerAddressProvider.class).toInstance(new InterestPeerAddressProvider(interestPeers));
                        bind(ReplicationPeerAddressesProvider.class).toInstance(new ReplicationPeerAddressesProvider(replicationPeers));
                        if (networkRouter != null) {
                            bind(NetworkRouter.class).toInstance(networkRouter);
                            bind(TcpRegistrationServer.class).to(EmbeddedTcpRegistrationServer.class);
                            bind(TcpDiscoveryServer.class).to(EmbeddedTcpDiscoveryServer.class);
                            bind(TcpReplicationServer.class).to(EmbeddedTcpReplicationServer.class);
                        }
                    }
                },
                new Eureka1RestApiModule(new Eureka1Configuration(), ServerType.Write)
        };

        setup(modules);
    }

    @Override
    protected void loadInstanceProperties(Properties props) {
        super.loadInstanceProperties(props);
        props.setProperty("eureka.client.discovery-endpoint.port", Integer.toString(config.getDiscoveryPort()));
    }

    public int getRegistrationPort() {
        // Since server might be started on the ephemeral port, we need to get it directly from RxNetty server
        return injector.getInstance(TcpRegistrationServer.class).serverPort();
    }

    public int getDiscoveryPort() {
        // Since server might be started on the ephemeral port, we need to get it directly from RxNetty server
        return injector.getInstance(TcpDiscoveryServer.class).serverPort();
    }

    public int getReplicationPort() {
        // Since server might be started on the ephemeral port, we need to get it directly from RxNetty server
        return injector.getInstance(TcpReplicationServer.class).serverPort();
    }

    public ServerResolver getRegistrationResolver() {
        return ServerResolvers.fromHostname("localhost").withPort(getRegistrationPort());
    }

    @Override
    public ServerResolver getInterestResolver() {
        return ServerResolvers.fromHostname("localhost").withPort(getDiscoveryPort());
    }

    @Override
    public WriteServerReport serverReport() {
        return new WriteServerReport(
                getRegistrationPort(),
                getDiscoveryPort(),
                getReplicationPort(),
                getEurekaServerRegistry().size(), getHttpServerPort(),
                getWebAdminPort()
        );
    }

    public static class WriteServerReport extends AbstractServerReport {
        private final int registrationPort;
        private final int discoveryPort;
        private final int replicationPort;
        private final int registrySize;

        public WriteServerReport(int registrationPort, int discoveryPort, int replicationPort,
                                 int registrySize, int httpServerPort, int adminPort) {
            super(httpServerPort, adminPort);
            this.registrationPort = registrationPort;
            this.discoveryPort = discoveryPort;
            this.replicationPort = replicationPort;
            this.registrySize = registrySize;
        }

        public int getRegistrationPort() {
            return registrationPort;
        }

        public int getDiscoveryPort() {
            return discoveryPort;
        }

        public int getReplicationPort() {
            return replicationPort;
        }

        public int getRegistrySize() {
            return registrySize;
        }
    }
}


File: eureka2-testkit/src/main/java/com/netflix/eureka2/testkit/junit/resources/EurekaDeploymentResource.java
package com.netflix.eureka2.testkit.junit.resources;

import com.netflix.eureka2.client.EurekaInterestClient;
import com.netflix.eureka2.client.EurekaRegistrationClient;
import com.netflix.eureka2.config.BasicEurekaTransportConfig;
import com.netflix.eureka2.config.EurekaTransportConfig;
import com.netflix.eureka2.testkit.embedded.EurekaDeployment;
import com.netflix.eureka2.testkit.embedded.EurekaDeployment.EurekaDeploymentBuilder;
import com.netflix.eureka2.testkit.junit.resources.EurekaExternalResources.EurekaExternalResource;

/**
 * @author Tomasz Bak
 */
public class EurekaDeploymentResource extends EurekaExternalResource {

    private final int writeClusterSize;
    private final int readClusterSize;
    private final EurekaTransportConfig transportConfig;
    private final boolean networkRouterEnabled;

    private EurekaDeployment eurekaDeployment;

    /**
     * Use builder instead {@link EurekaDeploymentResourceBuilder}.
     */
    @Deprecated
    public EurekaDeploymentResource(int writeClusterSize, int readClusterSize) {
        this(writeClusterSize, readClusterSize, new BasicEurekaTransportConfig.Builder().build());
    }

    /**
     * Use builder instead {@link EurekaDeploymentResourceBuilder}.
     */
    @Deprecated
    public EurekaDeploymentResource(int writeClusterSize, int readClusterSize, EurekaTransportConfig transportConfig) {
        this.writeClusterSize = writeClusterSize;
        this.readClusterSize = readClusterSize;
        this.transportConfig = transportConfig;
        this.networkRouterEnabled = false;
    }

    private EurekaDeploymentResource(EurekaDeploymentResourceBuilder builder) {
        this.writeClusterSize = builder.writeClusterSize;
        this.readClusterSize = builder.readClusterSize;
        this.transportConfig = builder.transportConfig;
        this.networkRouterEnabled = builder.networkRouterEnabled;
    }

    public EurekaDeployment getEurekaDeployment() {
        return eurekaDeployment;
    }

    /**
     * Create a {@link EurekaRegistrationClient} instance to register with a particular write server
     *
     * @param idx id of a write server where to connect
     */
    public EurekaRegistrationClient registrationClientToWriteServer(int idx) {
        return eurekaDeployment.registrationClientToWriteServer(idx);
    }

    /**
     * Create a {@link EurekaRegistrationClient} instance to register with any instance in a write cluster
     */
    public EurekaRegistrationClient registrationClientToWriteCluster() {
        return eurekaDeployment.registrationClientToWriteCluster();
    }

    /**
     * Create a {@link EurekaInterestClient} instance to do interest discovery with a particular write server
     *
     * @param idx id of a write server where to connect
     */
    public EurekaInterestClient interestClientToWriteServer(int idx) {
        return eurekaDeployment.interestClientToWriteServer(idx);
    }

    /**
     * Create a {@link EurekaInterestClient} instance to do interest discovery with any instance in a write cluster
     */
    public EurekaInterestClient interestClientToWriteCluster() {
        return eurekaDeployment.interestClientToWriteCluster();
    }

    /**
     * Create a {@link EurekaInterestClient} instance to do interest discovery with a particular read server
     *
     * @param idx id of a write server where to connect
     */
    public EurekaInterestClient interestClientToReadServer(int idx) {
        return eurekaDeployment.interestClientToReadServer(idx);
    }

    /**
     * Create a {@link EurekaInterestClient} instance to do interest discovery with any instance in a read cluster
     */
    public EurekaInterestClient interestClientToReadCluster() {
        return eurekaDeployment.interestClientToReadCluster();
    }

    /**
     * Create a {@link EurekaInterestClient} instance to do interest discovery with any instance in a read cluster,
     * using the canonical method to first discover the read cluster from the write cluster
     */
    public EurekaInterestClient cannonicalInterestClient() {
        return eurekaDeployment.cannonicalInterestClient();
    }

    @Override
    protected void before() throws Throwable {
        eurekaDeployment = new EurekaDeploymentBuilder()
                .withWriteClusterSize(writeClusterSize)
                .withReadClusterSize(readClusterSize)
                .withEphemeralPorts(true)
                .withTransportConfig(transportConfig)
                .withNetworkRouter(networkRouterEnabled)
                .build();
    }

    @Override
    protected void after() {
        if (eurekaDeployment != null) {
            eurekaDeployment.shutdown();
        }
    }

    public static EurekaDeploymentResourceBuilder anEurekaDeploymentResource(int writeClusterSize, int readClusterSize) {
        return new EurekaDeploymentResourceBuilder(writeClusterSize, readClusterSize);
    }

    public static class EurekaDeploymentResourceBuilder {

        private final int writeClusterSize;
        private final int readClusterSize;

        private EurekaTransportConfig transportConfig;
        private boolean networkRouterEnabled;

        public EurekaDeploymentResourceBuilder(int writeClusterSize, int readClusterSize) {
            this.writeClusterSize = writeClusterSize;
            this.readClusterSize = readClusterSize;
        }

        public EurekaDeploymentResourceBuilder withNetworkRouter(boolean networkRouterEnabled) {
            this.networkRouterEnabled = networkRouterEnabled;
            return this;
        }

        public EurekaDeploymentResourceBuilder withTransportConfig(EurekaTransportConfig transportConfig) {
            this.transportConfig = transportConfig;
            return this;
        }

        public EurekaDeploymentResource build() {
            return new EurekaDeploymentResource(this);
        }
    }
}


File: eureka2-testkit/src/main/java/com/netflix/eureka2/testkit/junit/resources/ReadServerResource.java
package com.netflix.eureka2.testkit.junit.resources;

import com.netflix.eureka2.client.resolver.ServerResolver;
import com.netflix.eureka2.client.resolver.ServerResolvers;
import com.netflix.eureka2.registry.datacenter.LocalDataCenterInfo.DataCenterType;
import com.netflix.eureka2.server.config.EurekaServerConfig;
import com.netflix.eureka2.server.transport.tcp.discovery.TcpDiscoveryServer;
import com.netflix.eureka2.testkit.embedded.server.EmbeddedReadServer;
import com.netflix.eureka2.testkit.junit.resources.EurekaExternalResources.EurekaExternalResource;
import com.netflix.eureka2.codec.CodecType;

/**
 * @author Tomasz Bak
 */
public class ReadServerResource extends EurekaExternalResource {

    public static final String DEFAULT_READ_CLUSTER_NAME = "read-test";
    public static final String EMBEDDED_READ_CLIENT_ID = "embeddedReadClient";

    private final String name;
    private final WriteServerResource writeServerResource;
    private final CodecType codec;

    private EmbeddedReadServer server;
    private int discoveryPort;

    public ReadServerResource(WriteServerResource writeServerResource) {
        this(DEFAULT_READ_CLUSTER_NAME, writeServerResource);
    }

    public ReadServerResource(String name, WriteServerResource writeServerResource) {
        this(name, writeServerResource, CodecType.Avro);
    }

    public ReadServerResource(String name, WriteServerResource writeServerResource, CodecType codec) {
        this.name = name;
        this.writeServerResource = writeServerResource;
        this.codec = codec;
    }

    @Override
    protected void before() throws Throwable {
        EurekaServerConfig config = EurekaServerConfig.baseBuilder()
                .withAppName(name)
                .withVipAddress(name)
                .withDataCenterType(DataCenterType.Basic)
                .withHttpPort(0)
                .withDiscoveryPort(0)
                .withShutDownPort(0)
                .withWebAdminPort(0)
                .withCodec(codec)
                .build();
        ServerResolver registrationResolver = ServerResolvers.fromHostname("localhost").withPort(writeServerResource.getRegistrationPort());
        ServerResolver discoveryResolver = ServerResolvers.fromHostname("localhost").withPort(writeServerResource.getDiscoveryPort());
        server = new EmbeddedReadServer(EMBEDDED_READ_CLIENT_ID, config, registrationResolver, discoveryResolver, null, false, false);
        server.start();

        // Find ephemeral port numbers
        discoveryPort = server.getInjector().getInstance(TcpDiscoveryServer.class).serverPort();
    }

    @Override
    protected void after() {
        if (server != null) {
            server.shutdown();
        }
    }

    public String getName() {
        return name;
    }

    public int getDiscoveryPort() {
        return discoveryPort;
    }

    public ServerResolver getInterestResolver() {
        return ServerResolvers.fromHostname("localhost").withPort(discoveryPort);
    }
}


File: eureka2-testkit/src/main/java/com/netflix/eureka2/testkit/junit/resources/WriteServerResource.java
package com.netflix.eureka2.testkit.junit.resources;

import com.netflix.eureka2.Server;
import com.netflix.eureka2.client.resolver.ServerResolver;
import com.netflix.eureka2.codec.CodecType;
import com.netflix.eureka2.interests.ChangeNotification;
import com.netflix.eureka2.registry.datacenter.LocalDataCenterInfo.DataCenterType;
import com.netflix.eureka2.server.config.WriteServerConfig;
import com.netflix.eureka2.testkit.embedded.server.EmbeddedWriteServer;
import com.netflix.eureka2.testkit.junit.resources.EurekaExternalResources.EurekaExternalResource;
import rx.Observable;

/**
 * @author Tomasz Bak
 */
public class WriteServerResource extends EurekaExternalResource {

    public static final String DEFAULT_WRITE_CLUSTER_NAME = "write-test";

    private final String name;
    private final String readClusterName;
    private final CodecType codec;

    private EmbeddedWriteServer server;

    public WriteServerResource() {
        this(DEFAULT_WRITE_CLUSTER_NAME, ReadServerResource.DEFAULT_READ_CLUSTER_NAME);
    }

    public WriteServerResource(String name, String readClusterName) {
        this(name, readClusterName, CodecType.Avro);
    }

    public WriteServerResource(String name, String readClusterName, CodecType codec) {
        this.name = name;
        this.readClusterName = readClusterName;
        this.codec = codec;
    }

    @Override
    protected void before() throws Throwable {
        WriteServerConfig config = WriteServerConfig.writeBuilder()
                .withAppName(name)
                .withVipAddress(name)
                .withReadClusterVipAddress(readClusterName)
                .withDataCenterType(DataCenterType.Basic)
                .withHttpPort(0)
                .withRegistrationPort(0)
                .withDiscoveryPort(0)
                .withReplicationPort(0)
                .withCodec(codec)
                .withShutDownPort(0)
                .withWebAdminPort(0)
                .withReplicationRetryMillis(1000)
                .build();

        Observable<ChangeNotification<Server>> noPeers = Observable.never();
        server = new EmbeddedWriteServer(config, noPeers, noPeers, null, false, false);
        server.start();
    }

    @Override
    protected void after() {
        if (server != null) {
            server.shutdown();
        }
    }

    public String getName() {
        return name;
    }

    public int getRegistrationPort() {
        return server.getRegistrationPort();
    }

    public int getDiscoveryPort() {
        return server.getDiscoveryPort();
    }

    public ServerResolver getRegistrationResolver() {
        return server.getRegistrationResolver();
    }

    public ServerResolver getInterestResolver() {
        return server.getInterestResolver();
    }

    public EmbeddedWriteServer getServer() {
        return server;
    }
}


File: eureka2-testkit/src/main/java/com/netflix/eureka2/testkit/netrouter/NetworkLink.java
package com.netflix.eureka2.testkit.netrouter;

import java.util.concurrent.TimeUnit;

/**
 *  A link between two servers with capabilities to inject different transmission properties
 * (throughput, data loss, etc).
 *
 * @author Tomasz Bak
 */
public interface NetworkLink {

    enum BandwidthUnit {Bits, Kb, Mb, Gb}

    boolean isUp();

    /**
     * Connect two endpoints.
     *
     * @return true if the connection actually happened (endpoints where disconnected prior to calling this method)
     */
    boolean connect();

    /**
     * Disconnect two endpoints.
     *
     * @return true if the disconnect actually happened (endpoints where connected prior to calling this method)
     */
    boolean disconnect();

    /**
     * Limit link bandwidth to a given throughput, queueing up excessive data.
     */
    void limitBandwidthTo(int throughput, BandwidthUnit bandwidthUnit);

    /**
     * Do not impose any constraints on link throughput.
     *
     * @return true if the link's throughput was previously constraint
     */
    boolean openUnlimitedBandwidth();

    /**
     * Fixed link latency.
     */
    void injectLatency(long time, TimeUnit timeUnit);

    /**
     * Latency with variability limited by jitterAmplitude.
     */
    void injectLatency(long time, long jitterAmplitude, TimeUnit timeUnit);
}


File: eureka2-testkit/src/main/java/com/netflix/eureka2/testkit/netrouter/NetworkRouter.java
package com.netflix.eureka2.testkit.netrouter;

/**
 * Network connector for Eureka servers and clients with capability to inject network level
 * errors into the test system.
 *
 * @author Tomasz Bak
 */
public interface NetworkRouter {

    /**
     * Create bridge server endpoint connecting to the given target server.
     * By default the connectivity is enabled with no restrictions.
     */
    int bridgeTo(int targetPort);

    /**
     * Shutdown and remove a bridge server belonging to the given target port. This also terminates
     * all client connections.
     */
    void removeBridgeTo(int targetPort);

    /**
     * A link between two servers with capabilities to inject different transmission properties
     * (throughput, data loss, etc).
     */
    NetworkLink getLinkTo(int port);

    /**
     * Shutdown all bridge servers.
     */
    void shutdown();
}


File: eureka2-testkit/src/main/java/com/netflix/eureka2/testkit/netrouter/NetworkRouters.java
package com.netflix.eureka2.testkit.netrouter;

import com.netflix.eureka2.testkit.netrouter.internal.NetworkRouterImpl;

/**
 * A factory class for {@link NetworkRouter} instances.
 *
 * @author Tomasz Bak
 */
public final class NetworkRouters {

    private NetworkRouters() {
    }

    public static NetworkRouter aRouter() {
        return new NetworkRouterImpl();
    }
}


File: eureka2-testkit/src/main/java/com/netflix/eureka2/testkit/netrouter/internal/LinkEvent.java
package com.netflix.eureka2.testkit.netrouter.internal;

import com.netflix.eureka2.testkit.netrouter.NetworkLink;

/**
 * @author Tomasz Bak
 */
public class LinkEvent extends NetworkEvent {
    public LinkEvent(NetworkLink networkLink) {
    }
}


File: eureka2-testkit/src/main/java/com/netflix/eureka2/testkit/netrouter/internal/NetworkEvent.java
package com.netflix.eureka2.testkit.netrouter.internal;

/**
 * @author Tomasz Bak
 */
public abstract class NetworkEvent {
}


File: eureka2-testkit/src/main/java/com/netflix/eureka2/testkit/netrouter/internal/NetworkLinkImpl.java
package com.netflix.eureka2.testkit.netrouter.internal;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;

import com.netflix.eureka2.testkit.netrouter.NetworkLink;
import rx.Observable;
import rx.subjects.PublishSubject;
import rx.subjects.SerializedSubject;
import rx.subjects.Subject;

/**
 * @author Tomasz Bak
 */
public class NetworkLinkImpl implements NetworkLink {

    private final AtomicBoolean isConnected = new AtomicBoolean(true);

    private final Subject<LinkEvent, LinkEvent> linkEventSubject = new SerializedSubject<>(PublishSubject.<LinkEvent>create());

    public Observable<LinkEvent> linkEvents() {
        return linkEventSubject;
    }

    @Override
    public boolean isUp() {
        return isConnected.get();
    }

    @Override
    public boolean connect() {
        boolean hasChanged = isConnected.compareAndSet(false, true);
        if (hasChanged) {
            linkEventSubject.onNext(new LinkEvent(this));
        }
        return hasChanged;
    }

    @Override
    public boolean disconnect() {
        boolean hasChanged = isConnected.compareAndSet(true, false);
        if (hasChanged) {
            linkEventSubject.onNext(new LinkEvent(this));
        }
        return hasChanged;
    }

    @Override
    public void limitBandwidthTo(int throughput, BandwidthUnit bandwidthUnit) {
        throw new IllegalStateException("not implemented yet");
    }

    @Override
    public boolean openUnlimitedBandwidth() {
        throw new IllegalStateException("not implemented yet");
    }

    @Override
    public void injectLatency(long time, TimeUnit timeUnit) {
        throw new IllegalStateException("not implemented yet");
    }

    @Override
    public void injectLatency(long time, long jitterAmplitude, TimeUnit timeUnit) {
        throw new IllegalStateException("not implemented yet");
    }
}


File: eureka2-testkit/src/main/java/com/netflix/eureka2/testkit/netrouter/internal/NetworkRouterImpl.java
package com.netflix.eureka2.testkit.netrouter.internal;

import javax.annotation.PreDestroy;
import javax.inject.Singleton;
import java.util.HashMap;
import java.util.Map;

import com.netflix.eureka2.testkit.netrouter.NetworkLink;
import com.netflix.eureka2.testkit.netrouter.NetworkRouter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * @author Tomasz Bak
 */
@Singleton
public class NetworkRouterImpl implements NetworkRouter {

    private static final Logger logger = LoggerFactory.getLogger(NetworkRouterImpl.class);

    private final Map<Integer, RouterPort> routerSocketsByPort1 = new HashMap<>();
    private final Map<Integer, RouterPort> routerSocketsByPort2 = new HashMap<>();

    @Override
    public int bridgeTo(int targetPort) {
        RouterPort routerPort = new RouterPort(targetPort);
        int localPort = routerPort.getLocalPort();

        routerSocketsByPort1.put(targetPort, routerPort);
        routerSocketsByPort1.put(localPort, routerPort);

        logger.info("Port {} shadowed by {}", targetPort, localPort);

        return localPort;
    }

    @Override
    public void removeBridgeTo(int targetPort) {
        RouterPort routerPort = routerSocketsByPort1.remove(targetPort);
        if (routerPort == null) {
            routerPort = routerSocketsByPort2.remove(targetPort);
        }
        if (routerPort != null) {
            routerPort.shutdown();
        }
    }

    @Override
    public NetworkLink getLinkTo(int port) {
        RouterPort routerPort = routerSocketsByPort1.get(port);
        if (routerPort == null) {
            routerPort = routerSocketsByPort2.get(port);
        }
        return routerPort == null ? null : routerPort.getLink();
    }

    @PreDestroy
    @Override
    public void shutdown() {
        for (RouterPort routerPort : routerSocketsByPort1.values()) {
            routerPort.shutdown();
        }
        routerSocketsByPort1.clear();
        routerSocketsByPort2.clear();
    }
}


File: eureka2-testkit/src/main/java/com/netflix/eureka2/testkit/netrouter/internal/RouterPort.java
package com.netflix.eureka2.testkit.netrouter.internal;

import java.util.Collections;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

import com.netflix.eureka2.testkit.netrouter.NetworkLink;
import io.netty.buffer.ByteBuf;
import io.reactivex.netty.RxNetty;
import io.reactivex.netty.channel.ConnectionHandler;
import io.reactivex.netty.channel.ObservableConnection;
import io.reactivex.netty.client.RxClient;
import io.reactivex.netty.server.RxServer;
import rx.Observable;
import rx.Subscriber;
import rx.functions.Action0;
import rx.functions.Action1;
import rx.functions.Func1;
import rx.subjects.ReplaySubject;

/**
 * Internal abstraction that represents a single port proxied by a router.
 *
 * @author Tomasz Bak
 */
public class RouterPort {

    private final int targetPort;
    private final int localPort;
    private final NetworkLinkImpl link;
    private final RxClient<ByteBuf, ByteBuf> rxClient;

    private volatile RxServer<ByteBuf, ByteBuf> rxServer;
    private final Set<ObservableConnection<?, ?>> pendingConnections = Collections.newSetFromMap(new ConcurrentHashMap<ObservableConnection<?, ?>, Boolean>());

    public RouterPort(int targetPort) {
        this.targetPort = targetPort;
        this.link = new NetworkLinkImpl();
        rxClient = RxNetty.<ByteBuf, ByteBuf>newTcpClientBuilder("localhost", targetPort).build();
        link.linkEvents().subscribe(
                new Action1<LinkEvent>() {
                    @Override
                    public void call(LinkEvent linkEvent) {
                        handleLinkUpdates(linkEvent);
                    }
                }
        );
        openPort(0);
        this.localPort = rxServer.getServerPort();
    }

    private void handleLinkUpdates(LinkEvent linkEvent) {
        if (link.isUp()) {
            openPort(localPort);
        } else {
            closePort();
        }
    }

    public int getLocalPort() {
        return localPort;
    }

    public int getTargetPort() {
        return targetPort;
    }

    public NetworkLink getLink() {
        return link;
    }

    public void shutdown() {
        closePort();
    }

    private void openPort(int port) {
        if (rxServer != null) {
            return;
        }
        rxServer = RxNetty.newTcpServerBuilder(port, new ConnectionHandler<ByteBuf, ByteBuf>() {
            @Override
            public Observable<Void> handle(ObservableConnection<ByteBuf, ByteBuf> newConnection) {
                return bridgeConnection(newConnection);
            }
        }).build().start();
    }

    private void closePort() {
        if (rxServer != null) {
            try {
                rxServer.shutdown();
            } catch (InterruptedException ignore) {
            }
            rxServer = null;
            for (ObservableConnection<?, ?> connection : pendingConnections) {
                connection.close();
            }
            pendingConnections.clear();
        }
    }

    private Observable<Void> bridgeConnection(final ObservableConnection<ByteBuf, ByteBuf> clientConnection) {
        pendingConnections.add(clientConnection);

        // FIXME Using reply subject is a memory leak
        final ReplaySubject<ByteBuf> forwardingSubject = ReplaySubject.create();

        Observable<Void> clientToServerForwarder = clientConnection.getInput().flatMap(
                new Func1<ByteBuf, Observable<Void>>() {
                    @Override
                    public Observable<Void> call(ByteBuf byteBuf) {
                        forwardingSubject.onNext(byteBuf.retain());
                        return Observable.empty();
                    }
                });

        Observable<Void> serverToClient = rxClient.connect().flatMap(
                new Func1<ObservableConnection<ByteBuf, ByteBuf>, Observable<Void>>() {
                    @Override
                    public Observable<Void> call(final ObservableConnection<ByteBuf, ByteBuf> targetConnection) {
                        forwardingSubject.subscribe(new Subscriber<ByteBuf>() {
                            @Override
                            public void onCompleted() {
                                targetConnection.close();
                            }

                            @Override
                            public void onError(Throwable e) {
                                targetConnection.close();
                            }

                            @Override
                            public void onNext(ByteBuf byteBuf) {
                                targetConnection.writeAndFlush(byteBuf);
                            }
                        });

                        return targetConnection.getInput().flatMap(new Func1<ByteBuf, Observable<Void>>() {
                            @Override
                            public Observable<Void> call(ByteBuf byteBuf) {
                                byteBuf.retain();
                                return clientConnection.writeAndFlush(byteBuf);
                            }
                        }).doOnError(new Action1<Throwable>() {
                            @Override
                            public void call(Throwable e) {
                                clientConnection.close();
                            }
                        });
                    }
                });
        return Observable.merge(clientToServerForwarder, serverToClient)
                .doOnTerminate(new Action0() {
                    @Override
                    public void call() {
                        forwardingSubject.onCompleted();
                        pendingConnections.remove(clientConnection);
                    }
                });
    }
}


File: eureka2-testkit/src/test/java/com/netflix/eureka2/testkit/embedded/cluster/EmbeddedReadClusterTest.java
package com.netflix.eureka2.testkit.embedded.cluster;

import com.netflix.eureka2.client.resolver.ServerResolver;
import com.netflix.eureka2.server.config.EurekaServerConfig;
import com.netflix.eureka2.testkit.embedded.cluster.EmbeddedReadCluster.ReadClusterReport;
import com.netflix.eureka2.testkit.embedded.server.EmbeddedReadServer;
import org.junit.Before;
import org.junit.Test;

import static org.hamcrest.CoreMatchers.*;
import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

/**
 * @author Tomasz Bak
 */
public class EmbeddedReadClusterTest {

    private final EmbeddedReadServer readServer = mock(EmbeddedReadServer.class);

    private ServerResolver registrationResolver;
    private ServerResolver discoveryResolver;

    private EmbeddedReadCluster readCluster;

    @Before
    public void setUp() throws Exception {
        readCluster = new EmbeddedReadCluster(registrationResolver, discoveryResolver, false, false, true, null) {
            @Override
            protected EmbeddedReadServer newServer(EurekaServerConfig config) {
                return readServer;
            }
        };
    }

    @Test(timeout = 60000)
    public void testClusterScaleUp() throws Exception {
        readCluster.scaleUpBy(1);
        verify(readServer, times(1)).start();
    }

    @Test(timeout = 60000)
    public void testClusterScaleDown() throws Exception {
        readCluster.scaleUpBy(1);
        readCluster.scaleDownBy(1);
        verify(readServer, times(1)).shutdown();
    }

    @Test(timeout = 60000)
    public void testReportContent() throws Exception {
        readCluster.scaleUpByOne();

        ReadClusterReport report = readCluster.clusterReport();
        assertThat(report.getServerReports().size(), is(equalTo(1)));
    }
}

File: eureka2-testkit/src/test/java/com/netflix/eureka2/testkit/embedded/cluster/EmbeddedWriteClusterTest.java
package com.netflix.eureka2.testkit.embedded.cluster;

import java.util.List;

import com.netflix.eureka2.interests.ChangeNotification;
import com.netflix.eureka2.interests.ChangeNotification.Kind;
import com.netflix.eureka2.server.resolver.ClusterAddress.ServiceType;
import com.netflix.eureka2.server.config.WriteServerConfig;
import com.netflix.eureka2.testkit.embedded.cluster.EmbeddedWriteCluster.WriteClusterReport;
import com.netflix.eureka2.testkit.embedded.server.EmbeddedWriteServer;
import com.netflix.eureka2.Server;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import rx.observers.TestSubscriber;

import static java.util.Collections.*;
import static org.hamcrest.CoreMatchers.*;
import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

/**
 * @author Tomasz Bak
 */
public class EmbeddedWriteClusterTest {

    private final EmbeddedWriteServer writeServer = mock(EmbeddedWriteServer.class);

    private EmbeddedWriteCluster writeCluster;

    @Before
    public void setUp() throws Exception {
        writeCluster = new EmbeddedWriteCluster(false, false, false, null) {
            @Override
            protected EmbeddedWriteServer newServer(WriteServerConfig config) {
                return writeServer;
            }
        };
    }

    @After
    public void tearDown() throws Exception {
        writeCluster.shutdown();
    }

    @Test(timeout = 60000)
    public void testClusterScaleUp() throws Exception {
        writeCluster.scaleUpBy(1);

        verify(writeServer, times(1)).start();

        // Verify replication peers observable
        TestSubscriber<ChangeNotification<Server>> replicationPeerSubscriber = new TestSubscriber<>();
        writeCluster.resolvePeers(ServiceType.Replication).subscribe(replicationPeerSubscriber);

        replicationPeerSubscriber.assertNoErrors();
        assertThat(replicationPeerSubscriber.getOnNextEvents().size(), is(equalTo(1)));

        // Verify registration resolver returns the new server
        TestSubscriber<Server> registrationServerSubscriber = new TestSubscriber<>();
        writeCluster.registrationResolver().resolve().subscribe(registrationServerSubscriber);

        Server expectedServer = new Server("localhost", EmbeddedWriteCluster.WRITE_SERVER_PORTS_FROM);
        registrationServerSubscriber.assertReceivedOnNext(singletonList(expectedServer));

        // Verify discovery resolver returns the new server
        TestSubscriber<Server> discoveryServerSubscriber = new TestSubscriber<>();
        writeCluster.interestResolver().resolve().subscribe(discoveryServerSubscriber);

        expectedServer = new Server("localhost", EmbeddedWriteCluster.WRITE_SERVER_PORTS_FROM + 1);
        discoveryServerSubscriber.assertReceivedOnNext(singletonList(expectedServer));
    }

    @Test(timeout = 60000)
    public void testClusterScaleDown() throws Exception {
        writeCluster.scaleUpBy(2);

        // Subscribe to replication peer before scale down to catch server remove update
        TestSubscriber<ChangeNotification<Server>> replicationPeerSubscriber = new TestSubscriber<>();
        writeCluster.resolvePeers(ServiceType.Replication).subscribe(replicationPeerSubscriber);

        // Now scale down
        writeCluster.scaleDownBy(1);
        verify(writeServer, times(1)).shutdown();

        // Verify we have server remove
        List<ChangeNotification<Server>> updates = replicationPeerSubscriber.getOnNextEvents();
        assertThat(updates.size(), is(equalTo(3)));
        assertThat(updates.get(2).getKind(), is(equalTo(Kind.Delete)));
    }

    @Test(timeout = 60000)
    public void testReportContent() throws Exception {
        writeCluster.scaleUpByOne();

        WriteClusterReport report = writeCluster.clusterReport();
        assertThat(report.getServerReports().size(), is(equalTo(1)));
    }
}

File: eureka2-testkit/src/test/java/com/netflix/eureka2/testkit/embedded/server/EmbeddedWriteServerTest.java
package com.netflix.eureka2.testkit.embedded.server;

import java.util.List;

import com.netflix.eureka2.client.EurekaInterestClient;
import com.netflix.eureka2.client.EurekaRegistrationClient;
import com.netflix.eureka2.client.Eurekas;
import com.netflix.eureka2.client.registration.RegistrationObservable;
import com.netflix.eureka2.client.resolver.ServerResolvers;
import com.netflix.eureka2.interests.ChangeNotification;
import com.netflix.eureka2.interests.Interests;
import com.netflix.eureka2.registry.instance.InstanceInfo;
import com.netflix.eureka2.testkit.data.builder.SampleInstanceInfo;
import com.netflix.eureka2.testkit.junit.resources.EurekaDeploymentResource;
import org.junit.Rule;
import org.junit.Test;
import rx.Observable;

import static com.netflix.eureka2.testkit.junit.resources.EurekaDeploymentResource.anEurekaDeploymentResource;
import static org.hamcrest.CoreMatchers.equalTo;
import static org.hamcrest.CoreMatchers.is;
import static org.junit.Assert.assertThat;

/**
 * @author Tomasz Bak
 */
public class EmbeddedWriteServerTest {

    @Rule
    public final EurekaDeploymentResource eurekaDeploymentResource = anEurekaDeploymentResource(1, 0)
            .withNetworkRouter(true)
            .build();

    @Test(timeout = 10000)
    public void testRegistrationAndInterestServices() throws Exception {
        EmbeddedWriteServer writeServer = eurekaDeploymentResource.getEurekaDeployment().getWriteCluster().getServer(0);
        EurekaRegistrationClient registrationClient = Eurekas.newRegistrationClientBuilder()
                .withServerResolver(ServerResolvers.fromHostname("localhost").withPort(writeServer.getRegistrationPort()))
                .build();

        EurekaInterestClient interestClient = Eurekas.newInterestClientBuilder()
                .withServerResolver(ServerResolvers.fromHostname("localhost").withPort(writeServer.getDiscoveryPort()))
                .build();

        InstanceInfo instanceInfo = SampleInstanceInfo.DiscoveryServer.build();
        RegistrationObservable request = registrationClient.register(Observable.just(instanceInfo));
        request.subscribe();
        request.initialRegistrationResult().toBlocking().lastOrDefault(null);

        List<ChangeNotification<InstanceInfo>> notifications = interestClient
                .forInterest(Interests.forFullRegistry())
                .take(2)
                .toList()
                .toBlocking().single();

        assertThat(notifications.size(), is(equalTo(2)));

        registrationClient.shutdown();
        interestClient.shutdown();
    }
}

File: eureka2-testkit/src/test/java/com/netflix/eureka2/testkit/netrouter/internal/RouterPortTest.java
package com.netflix.eureka2.testkit.netrouter.internal;

import java.nio.charset.Charset;
import java.util.concurrent.TimeUnit;

import io.netty.buffer.ByteBuf;
import io.reactivex.netty.RxNetty;
import io.reactivex.netty.channel.ConnectionHandler;
import io.reactivex.netty.channel.ObservableConnection;
import io.reactivex.netty.server.RxServer;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import rx.Observable;
import rx.functions.Func1;
import rx.functions.Func2;

import static org.hamcrest.Matchers.equalTo;
import static org.hamcrest.Matchers.is;
import static org.junit.Assert.assertThat;
import static org.junit.Assert.fail;

/**
 * @author Tomasz Bak
 */
public class RouterPortTest {

    private RouterPort routerPort;

    private RxServer<ByteBuf, ByteBuf> server;

    @Before
    public void setUp() throws Exception {
        server = RxNetty.newTcpServerBuilder(0, new ConnectionHandler<ByteBuf, ByteBuf>() {
            @Override
            public Observable<Void> handle(final ObservableConnection<ByteBuf, ByteBuf> newConnection) {
                return newConnection.getInput().flatMap(new Func1<ByteBuf, Observable<Void>>() {
                    @Override
                    public Observable<Void> call(ByteBuf byteBuf) {
                        return newConnection.writeAndFlush(byteBuf.retain());
                    }
                });
            }
        }).build().start();
        routerPort = new RouterPort(server.getServerPort());
    }

    @After
    public void tearDown() throws Exception {
        if (server != null) {
            server.shutdown();
        }
    }

    @Test
    public void testDataAreForwardedToTargetPort() throws Exception {
        assertThat(sendHello(), is(equalTo("REPLY: HELLO!")));
    }

    @Test
    public void testLinkCanBeDisconnectedAndConnectedAgain() throws Exception {
        // First bring the link down and verify that connectivity is blocked
        routerPort.getLink().disconnect();
        try {
            sendHello();
            fail("Connection failure expected");
        } catch (Exception e) {
            // Good, connection failed as expected
        }

        // Now bring the link up, and verify that connectivity works again
        routerPort.getLink().connect();
        assertThat(sendHello(), is(equalTo("REPLY: HELLO!")));
    }

    private String sendHello() {
        return RxNetty.<ByteBuf, ByteBuf>newTcpClientBuilder("localhost", routerPort.getLocalPort()).build()
                .connect()
                .flatMap(new Func1<ObservableConnection<ByteBuf, ByteBuf>, Observable<String>>() {
                    @Override
                    public Observable<String> call(final ObservableConnection<ByteBuf, ByteBuf> connection) {
                        connection.writeStringAndFlush("HELLO!");
                        return connection.getInput().map(new Func1<ByteBuf, String>() {
                            @Override
                            public String call(ByteBuf byteBuf) {
                                connection.close();
                                return "REPLY: " + byteBuf.toString(Charset.defaultCharset());
                            }
                        });
                    }
                }).reduce(new StringBuilder(), new Func2<StringBuilder, String, StringBuilder>() {
                    @Override
                    public StringBuilder call(StringBuilder accumulator, String delta) {
                        return accumulator.append(delta);
                    }
                })
                .timeout(10, TimeUnit.SECONDS)
                .toBlocking()
                .first().toString();
    }
}